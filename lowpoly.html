<!DOCTYPE html>
<html>

<head>
    <title>GLTF Three.js Skeleton Interaction</title>
    <script type="importmap">
        {
          "imports": {
            "three": "https://unpkg.com/three@latest/build/three.module.js",
            "orbitControls": "https://unpkg.com/three/examples/jsm/controls/OrbitControls.js",
            "transformControls": "./js/penziltransform.js",
            "gltf" : "https://unpkg.com/three/examples/jsm/loaders/GLTFLoader.js",
            "vrm" : "https://unpkg.com/@pixiv/three-vrm@2.1.0/lib/three-vrm.module.js"
          }
        }
    </script>
  
</head>
<body>
    <script type = "module" src="./js/UIelements.js"></script>
    <script src="js/sceneStuff.js"></script>
    <script type="module">
        const THREE = await import('three');
        import { LayeredRender } from "./js/LayeredRender.js"
        import { TransformControls } from 'transformControls';
        import { OrbitControls } from 'orbitControls';
        import { GLTFLoader } from 'gltf';
        //import { VRMLoaderPlugin } from 'vrm';
        import { EWBIK } from "./js/EWBIK/EWBIK.js";
        import { IKNode, TrackingNode } from "./js/EWBIK/util/IKNodes.js";
        import { Rot } from "./js/EWBIK/util/Rot.js";
        import { IKPin } from "./js/EWBIK/betterbones/IKpin.js";
        import { Rest } from "./js/EWBIK/betterbones/Constraints/Rest/Rest.js";
        window.Rest = Rest;
        window.OrbitControls = OrbitControls;
        window.TransformControls = TransformControls;
        window.IKNode = IKNode;
        window.TrackingNode = TrackingNode;
        window.IKPin = IKPin;
        window.meshLayer = 0;
        window.boneLayer = 1;
        window.widgetLayer = 2;
        //import { Rest } from "./js/EWBIK/betterbones/Constraints/Rest/Rest.js"

        let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(-0.61, 1.2, -1);
        let renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        window.camera = camera;
        window.renderer = renderer;
        window.rendlrs = new LayeredRender(renderer, window.innerWidth, window.innerHeight, 
            (renderer, target) => { //renders mesh stuff
                camera.layers.set(meshLayer);
                renderer.setClearColor(new THREE.Color(0.5, 0.5, 0.5))
                renderer.render(scene, camera);
            },
            (renderer, target) => { //renders bones
                camera.layers.set(boneLayer);
                renderer.render(scene, camera);
            },
            (renderer, target) => { //renders bones
                camera.layers.set(widgetLayer);
                renderer.render(scene, camera);
            }
        );      
        
        const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x0f0f08, 7);
        const ambientLight = new THREE.AmbientLight(0x909090);
        hemisphereLight.layers.enable(boneLayer);
        ambientLight.layers.enable(boneLayer);

        let orbitControls, boneCtrls, pinOrientCtrls, pinTranslateCtrls;
        var scene = null;

        let selectedBone = null;
        let rootBone = null;

        const axesHelperSize = 24; // Adjust the size as needed
        window.boneAxesHelper = new THREE.AxesHelper(axesHelperSize);
        boneAxesHelper.layers.set(2);
        
       
        let armature = null;
        let frameCount = 0;
        window.instances = [];
        const loader = new GLTFLoader();
        window.autoSolve = true;
        addDebugFuncs(THREE);

        async function init() {
            // Scene
            scene = new THREE.Scene();
            scene.add(hemisphereLight);
            window.scene = scene;
            document.body.appendChild(renderer.domElement);
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            let inst1 = loadModel({ x: 0, y: 0, z: 0 });
            //let inst2 = loadModel({x: 0.5, y:0, z:0});
            window.addEventListener('resize', onWindowResize, false);
            initControls(THREE, renderer);

            //instances = await Promise.all([inst1, inst2]);
            render();
            ikify(await inst1);

            //const helper = new THREE.SkeletonHelper(rootBone);
            //helper.material.linewidth = 5; // Make the helper lines thicker
            //scene.add(helper);/=
        }

        let lastIK = 0;
        function ikify(inst) {
            //let mod1 = findBone(inst.scene);
            let rootNode = findThing(inst.scene, "RootNode");
            //mod1.remove(mod1[0]);
            let armature = new EWBIK(rootNode[0]);
            window.skeletonHelper = new THREE.SkeletonHelper(inst.scene);
            scene.add(skeletonHelper);
            rootBone = armature.rootBone;
            armature.armatureNode.forceOrthonormality = false;
            window.armatures.push(armature);
            armature.inferOrientations(armature.rootBone);
            printBoneNames(rootBone);            
            initHumanoidRestConstraints(armature);
            armature.showBones(0.1, true);
            initIK(armature);
            updateGlobalPinLists();
            updateGlobalBoneLists();
            //addSceneArmature(armature);
            /*let armature2 = new EWBIK(instances[1].scene.children[0]);
            armature2.armatureNode.forceOrthonormality = false;
            addSceneArmature(armature2);*/
        }

        async function loadModel(position) {
            let glb = await loader.loadAsync(
                './vrmtests/cyber_girl/scene.gltf',
                //'./vrmtests/micha.glb',
                (xhr) => { console.log(`${(xhr.loaded / xhr.total * 100)}% loaded`); },
                (error) => { console.log('An error happened'); }
            );
            scene.add(glb.scene);
            return glb;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            render();
        }

        async function animate() {
            if (autoSolve) {
                doSolve();
            }
            requestAnimationFrame(animate);
            render(true);
        }


        function initHumanoidRestConstraints(armature) {

            /*for(let b of armature.bones) {
                if(b.parent instanceof THREE.Bone) {
                    let restconst = new Rest(b);
                    if(b == armature.bonetags["J_Bip_C_Head"]) {
                        restconst.setPainfulness(0.95);
                        restconst.setStockholmRate(0.8);
                    }
                }
            }*/
            /*/armature.hair_pin = new IKPin(armature.bonetags['prefix_dyn_hair7_059']);
            armature.head_pin = new IKPin(armature.bonetags["prefix_root_01"]);
            armature.r_foot_pin = new IKPin(armature.bonetags["prefix_foot_r_069"]);
            armature.r_hand_pin = new IKPin(armature.bonetags["prefix_hand_r_030"]);
            armature.l_foot_pin = new IKPin(armature.bonetags["prefix_foot_l_063"]);
            armature.l_hand_pin = new IKPin(armature.bonetags["prefix_hand_l_09"]);
            //armature.head_pin.setPinWeight(2);*/

            /*for (let b of armature.bones) {
                if (b.parent instanceof THREE.Bone)
                    new Rest(b);
            }*/

        }

        window.render = function (incrFrame = false) {
            if (incrFrame) frameCount++;
            //setPinVisibility(frameCount%2 == 0);
            window.rendlrs.render();
        }

        /*window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children);
            if (intersects.length > 0 && intersectsDisplay != null) {
                let intersect = intersects[0]; // Closest intersected object
                for(let inx of intersects) {
                    if(inx?.object?.visible) {
                        intersect = inx;
                        break;
                    }
                    console.log('what');
                }
                intersectsDisplay.innerText = `
                Intersected Coordinates: ${intersect.point.x.toFixed(2)}, ${intersect.point.y.toFixed(2)}, ${intersect.point.z.toFixed(2)} 
                ${intersect?.object?.type ?? ''} : ${intersect?.object?.name ?? intersect?.object?.ikd }`;
                //console.log(intersects);
            }
        })*/

        init();
        animate();
    </script>
</body>

</html>