<!DOCTYPE html>
<html>

<head>
    <title>Three.js Skeleton Interaction</title>
    <script> global = window;</script>
    <script type="importmap">
        {
          "imports": {
            "three": "./js/three/three.module.js",
            "orbitControls": "./js/three/jsm/OrbitControls.js",
            "transformControls": "./js/penziltransform.js",
            "gltf" : "./js/three/jsm/GLTFLoader.js",
            "vrm" : "./js/three/jsm/three-vrm.module.js",
            "convexGeo": "./js/EWBIK/util/mathdump/ConvexHull.js",
            "enviro" : "./js/environment.js",
            "uiElements" : "./js/UIelements.js"
          }
        }
    </script>

</head>


<body>
    <script type="module" src="./js/UIelements.js"></script>
    <script src="js/sceneStuff.js"></script>
    <script type="module">
        import *  as THREE from "three";
        import * as uielems from "uiElements";
        import { LayeredRender } from "./js/LayeredRender.js"
        import { TransformControls } from 'transformControls';
        import { OrbitControls } from 'orbitControls';
        import { GLTFLoader } from 'gltf';
        import { EWBIK } from "./js/EWBIK/EWBIK.js";
        import { IKSkelHelper } from "./js/EWBIK/helpers/IKSkelHelper.js"; 
        import { IKNode} from "./js/EWBIK/util/nodes/IKNodes.js";
        import { ShadowNode} from "./js/EWBIK/util/nodes/ShadowNode.js";
        import { IKPin } from "./js/EWBIK/betterbones/IKpin.js";
        import { Rest, Kusudama, Twist } from "./js/EWBIK/betterbones/Constraints/ConstraintStack.js";
        import { getMeshDescendants, initEnvironment, setShadowD} from "enviro";
        import {initSenua, initSenuaShortcuts, initSenuaConstraints, initSenuaPins} from "./js/toys/rigs/senua.js";
        //import { Rest } from "./js/EWBIK/betterbones/Constraints/Rest/Rest.js"
        addDebugFuncs(THREE);
        window.Rest = Rest;
        window.OrbitControls = OrbitControls;
        window.TransformControls = TransformControls;
        window.IKNode = IKNode;
        window.IKPin = IKPin;
        window.autoSolve = true;
        window.getMeshDescendants = getMeshDescendants; window.setShadowD = setShadowD;

        window.meshLayer = 0;
        window.boneLayer = 1;

        let camera = new THREE.PerspectiveCamera(10, window.innerWidth / window.innerHeight, 0.01, 1000);
        camera.position.set(0.5907470452024858, 1.8701419070385126, 2.8771281921815253);
        window.renderer = new THREE.WebGLRenderer({ antialias: true });
        window.scene =  new THREE.Scene();
        renderer.setClearColor(0x000000, 0);
        renderer.setSize(window.innerWidth, window.innerHeight);
        window.camera = camera;
        window.renderer = renderer;
        window.camTracker = new THREE.Object3D();
        window.scene.add(window.camTracker);
        window.camNode = new ShadowNode(window.camTracker, 'camera tracker', window.globalVecPool);
        window.camNode.forceOrthoNormality();

        let orbitControls, boneCtrls, pinOrientCtrls, pinTranslateCtrls;
        

        let selectedBone = null;
        let rootBone = null;
        let armature = null;
        window.frameCount = 0;
        window.instances = [];

        const loader = new GLTFLoader();

        async function init() {
            dirLight.position.z = 10;
            
            dirLight.intensity = 4;
            //scene.add(hemisphereLight);
            window.scene = scene;
            document.body.appendChild(renderer.domElement);
            //scene.add(ambientLight);
            window.addEventListener('resize', onWindowResize, false);
            window.autoSolve = false;
            window.interactionSolve = false;
            initControls(THREE, renderer);

            let inst1 = await loadModel({ x: 0, y: 0, z: 0 }, 0, ikify);
            //inst1.generateBoneMeshes(0.05, true, 'cone', 0.2);
            window.nek1 = inst1;
            armature = inst1;
            armature.setDefaultIterations(15);
            armature.setDampening(0.08);
            armature.dirtyRate = true;
            let helper = new IKSkelHelper(armature);
            helper.pinVisibilityCondition = (forPin, forBone) => uielems.contextPinCondition(forPin, forBone);
            helper.constraintVisibilityCondition = (forConstraint, forBone) => uielems.contextConstraintCondition(forConstraint, forBone); 
            helper.boneGeoMode = 'cone';
            window.armatureHelpers.push(helper);
            helper.init(1,2, -1, 4);
            updateSceneStuff();
            render();
            initEnvironment(scene, renderer, //scene,
                [...getMeshDescendants(nek1.armatureObj3d),
                ...getMeshDescendants(nek1.rootBone)],
                [0, 1, 2, 3]
            );

            setShadowD(2);
            //camera.lookAt(armature.bonetags['CC_Base_Head'].getWorldPosition(new THREE.Vector3()));

            //instances = await Promise.all([inst1, inst2]);
            //armature.solve();
            //render();
        }

        let lastIK = 0;
        function ikify(inst, loadId) {
            window.updateParseStream("Building IK Armature...", loadId);
            let armature = new EWBIK(inst);
            armature.armatureNode.forceOrthonormality = false;
            //armature.armatureObj3d.scale.set(0.004,0.004,0.004);
            //armature.armatureObj3d.rotateX(-Math.PI/2);
            armature.armatureNode.mimic();
            window.armatures.push(armature);

            window.updateParseStream("Inferring Bone directions and appearance...", loadId);
            initSenua(armature);
            //initSenuaShortcuts(armature);
            
            //initPrettyBones(armature, 'cone', 0.05, false);
            //initSenuaConstraints(armature);
            //initSenuaPins(armature);
            //armature.generateBoneMeshes(0.05, false, 'cone');
            window.updateParseStream("Addings constraints...", loadId);
            //initSenua(armature);
            
            armature.l_pupil_pin.target_threejs.position.z = 0.2;
            window.camTracker.add(armature.l_pupil_pin.target_threejs);
            armature.l_pupil_pin.ensure();
            
            armature.l_eyeball.getIKPin().target_threejs.position.set(0,0,0); 
            armature.l_eyeball.getIKPin().target_threejs.quaternion.set(0,0,0,1);
            armature.l_eyeball.getIKPin().targetNode.mimic();
            snapToFocus(armature.l_eyeball, 2);
            window.manualOrbit = true;
            setOrbit(armature.l_eyeball);
            window.updateParseStream("UI stuff...", loadId);            
            window.updateParseStream(null, loadId);
            return armature;
        }

        async function loadModel(position, loadId, onloaded) {

            let glb = await loader.loadAsync(
                './gltftests/senua.glb',
                (xhr, otherParam) => { window.updateLoadStream(xhr, loadId) },
                (error) => { window.notifyStreamError(error, loadId) }
            );
            glb.scene.traverse( function( object ) {
                object.frustumCulled = false;            
            });
            let startAt = findBone(glb.scene);
            scene.add(startAt.parent);
            startAt.scale.set(0.01, 0.01, 0.01);
            //startAt.parent.scale.set(1,1,1);
            window.updateParseStream("Scene instaniated...", loadId);
            return ikify(startAt, loadId);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            render();
        }

        async function animate() {
            requestAnimationFrame(animate);
            window.camTracker.position.copy(window.camera.position);
            window.camTracker.quaternion.copy(window.camera.quaternion);
            window.camNode.mimic();
            render(true);
        }


        init();
        animate();
    </script>
</body>

</html>