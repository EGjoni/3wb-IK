<!DOCTYPE html>
<html>

<head>
    <title>Three.js Skeleton Interaction</title>
    <script type="importmap">
        {
            "imports": {
                "three": "./js/three/three.module.js",
                "orbitControls": "./js/three/jsm/OrbitControls.js",                
                "transformControls": "./js/penziltransform.js",
                "gltf" : "./js/three/jsm/GLTFLoader.js",
                "convexGeo": "./js/EWBIK/util/mathdump/ConvexHull.js",
                "vrm" : "./js/three/jsm/three-vrm.module.js"
              }
        }
    </script>
</head>

<body>
    <!--<script type="module" src="./js/UIelements.js"></script>
    <script src="js/sceneStuff.js"></script>-->
    <div id="your-score">You:<span class="score">0</span></div>
    <div id="pounce-score">Pounce:<span class="score">0</span></div>
    <script type="module">
        import *  as THREE from "three";
        import { TransformControls } from 'transformControls';
        import { GLTFLoader } from 'gltf';
        import { VRMLoaderPlugin } from 'vrm';
        import { EWBIK, IKPin, IKTransform, Rest, ShadowNode, Vec3, Rot, Interpolator, any_Vec3} from "./js/EWBIK/EWBIK.js";
        import { OrbitControls } from "orbitControls";
        import { initWolfGirl, initWolfGirlShortcuts, initWolfGirlConstraints, initWolfgirlInteractivePins, initWolfGirlCosmeticPins } from "./js/toys/rigs/wolfgirl_vrm.js";
        const loader = new GLTFLoader();
        loader.register((parser) => {
            return new VRMLoaderPlugin(parser);
        });
        window.THREE = THREE;
        window.Rot = Rot;
        window.Vec3 = Vec3;
        window.camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.65, -2);
        camera.rotateY(Math.PI);
        window.renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setClearColor(0x000000, 0);
        renderer.setSize(window.innerWidth, window.innerHeight);
        const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x000000, 4.1);
        window.scene = new THREE.Scene();
        window.axHelp = new THREE.AxesHelper();
        window.axHelp2 = new THREE.AxesHelper();
        window.axHelp3 = new THREE.AxesHelper();
        window.axHelp4 = new THREE.AxesHelper();
        scene.add(hemisphereLight);
        document.body.appendChild(renderer.domElement);
        const itxmat = new THREE.MeshLambertMaterial({color: 0x004444});
        const itxPmat = new THREE.MeshLambertMaterial({color: 0x440044});
        const boxGeo = new THREE.BoxGeometry(0.03, 0.03, 0.03);//new THREE.DodecahedronGeometry(minx, 1);//, Math.random()*minDim*heightDelta); //
        window.boxMesh = new THREE.Mesh(boxGeo, itxmat);
        window.scoreHintGeo = new THREE.BoxGeometry(0.03, 0.03, 0.03);
        window.scoreHintMat = new THREE.MeshBasicMaterial({color: 0x00ff00});
        window.scoreHintMesh = new THREE.Mesh(scoreHintGeo, scoreHintMat)
        const sphereGeo = new THREE.SphereGeometry(0.7,9,9);
        window.itxBound = new THREE.Mesh(sphereGeo, itxmat);
        const mouseCaster = new THREE.Raycaster();
        const planeGeo = new THREE.PlaneGeometry(15,15);
        window.itxPlane = new THREE.Mesh(planeGeo, itxPmat);
        const mouse = new Vec3();
        const prevMouse = new Vec3();
        window.frameCount= 0;

        scene.add(itxBound);
        scene.add(boxMesh);
        scene.add(scoreHintMesh);
        boxMesh.visible=false;
        itxBound.position.set(0,1.3,0);
        //itxBound.material.transparent = true;
        itxBound.material.wireframe = false;
        //itxPlane.material.transparent = true;
        //itxPlane.material.opacity = 0.8;
        itxPmat.side = 2;
        boxMesh.position.set(0,1,0);
        scene.add(itxPlane);
        window.pounceScoreContainer = document.getElementById("pounce-score").querySelector("span");
        window.yourScoreContainer = document.getElementById("your-score").querySelector("span");
        
        const planeShadow = new ShadowNode(itxPlane);
        itxPlane.position.set(0, 1.5, -0.2);
        planeShadow.mimic();
        window.camShadow = new ShadowNode(camera);

        window.prepounce_l_targ3js = new THREE.Object3D();
        window.prepounce_r_targ3js = new THREE.Object3D();
        scene.add(prepounce_l_targ3js);
        scene.add(prepounce_r_targ3js);
        let prepounce_l_targ = new ShadowNode(prepounce_l_targ3js);
        let prepounce_r_targ = new ShadowNode(prepounce_r_targ3js);
        

        window.lookat=true;
        const useRest = false;
        const useLimiting = true;
        //window.orbitControls = new OrbitControls(camera, renderer.domElement);
        renderer.autoClear = false;
        let leftHandResting = true;
        let rightHandResting = true;
        let lastRightPounce = 0;
        let lastLeftPounce = 0;
        const pounceTimeAvgThresh = 600;
        const pounceTimeMinThresh = 200;
        let shyMin = 3000;
        let lastMotion = Date.now();
        let isMidPounce_left = false;
        let isMidPounce_right = false;
        let leftHandReturning = false;
        let rightHandReturning = false;
        let unShy = 0;

        let leftInterpolator= null;
        let rightInterpolator = null;
        window.leftGoal = new IKTransform();
        window.rightGoal = new IKTransform();
        rightGoal.rotation.setFromVecs(any_Vec3(0, 0,1).normalize(), any_Vec3(1, 0, 0).normalize());
        //window.leftGoal = new IKTransform(any_Vec3(0,0,0), any_Vec3(0,-1,0).normalize(), any_Vec3(0,0,1), any_Vec3(1,0,0).normalize());
        //window.rightGoal = new IKTransform(any_Vec3(0,0,0), any_Vec3(0.707,0.707,0).normalize(), any_Vec3(0,0,1), any_Vec3(.707,-0.707,0).normalize());

        async function init() {
            //load up a skeleton
            window.armature = await loadModel(0, ikify);
            armature.regenerateShadowSkeleton(true);
            unShy = Date.now();
            //initControls(THREE, renderer);
            //give the camera something interesting to look at.
            //armature.bonetags["J_Bip_C_Spine"].getWorldPosition(orbitControls.target);
            //orbitControls.update();
            animate();
        }

        function ikify(inst, loadId) {
            //window.updateParseStream("Building IK Armature...", loadId);
            let armature = new EWBIK(inst);
            armature.setDefaultIterations(15);
            armature.setDampening(0.8);
            armature.armatureNode.forceOrthonormality = false;
            //window.armatures.push(armature);

            //window.updateParseStream("Inferring Bone directions and appearance...", loadId);
            //initPrettyBones(armature);
            //window.updateParseStream("Addings constraints...", loadId);
            initWolfGirl(armature, useLimiting, useRest, false);
            //initWolfGirlShortcuts(armature);
            //initWolfGirlConstraints(armature);
            //makePinsList(1, armature.armatureObj3d, armature, true, true);
            //window.updateParseStream("UI stuff...", loadId);
            //updateGlobalBoneLists();
            initPose(armature);
            armature.regenerateShadowSkeleton(true);
            //window.updateParseStream(null, loadId);
            return armature;
        }

        
        

        function initPose(armature) {
            armature.hip_pin.target_threejs.position.y -= .2;
            armature.hip_pin.setDepthFalloff(0.8);
            armature.hip_pin.setPinWeight(0.4);
            armature.l_hand_pin.setPinWeight(1);
            armature.l_hand_pin.setXPriority(0.16);
            armature.l_hand_pin.setYPriority(0.0);
            armature.l_hand_pin.setZPriority(0);
            armature.l_hand_pin.target_threejs.add(axHelp3);
            armature.l_hand_pin.forBone.add(axHelp4);
            axHelp.visible = false; axHelp2.visible = false; axHelp3.visible = false; axHelp4.visible = false;

            armature.r_hand_pin.setPinWeight(1);
            armature.r_hand_pin.setXPriority(0.16);
            armature.r_hand_pin.setYPriority(0);
            armature.r_hand_pin.setZPriority(0);
            armature.r_hand_pin.target_threejs.add(axHelp);
            armature.r_hand_pin.forBone.add(axHelp2);



            let J_Bip_L_Hand_pin = armature.l_hand_pin;
            J_Bip_L_Hand_pin.target_threejs.position.set(-0.2628872730607969, 1.1320828172882704, -0.058023847915398);
            J_Bip_L_Hand_pin.target_threejs.quaternion.set(-0.466854980946203, -0.4415841689876301, 0.5158273464161427, 0.5665439057606263);
            J_Bip_L_Hand_pin.setTargetPriorities(0.5, 0.5, 0);
            //if(isRestOnly) {//Todo: This correcion shouldn't be necessary. Should figure out what's causing the difference
            //    J_Bip_L_Hand_pin.target_threejs.rotateZ(-1.5); 
            //}
            prepounce_l_targ.alignGlobalsTo(armature.l_hand_pin.targetNode.mimic().getGlobalMBasis()).project();
            leftInterpolator = new Interpolator(armature.l_hand_pin.targetNode, window.__tempVecPool);

            let J_Bip_R_Hand_pin = armature.r_hand_pin;
            J_Bip_R_Hand_pin.target_threejs.position.set(0.22725199632250082, 1.1271629356945718, -0.059638346652234);
            J_Bip_R_Hand_pin.target_threejs.quaternion.set(-0.4635192535441378, 0.4385467682483039, -0.5184121542461977, 0.5692762703491778);
            J_Bip_R_Hand_pin.setTargetPriorities(0.5, 0.5, 0);
            //if(isRestOnly) {//Todo: This correcion shouldn't be necessary. Should figure out what's causing the difference
            //    J_Bip_R_Hand_pin.target_threejs.rotateZ(1.5); 
            //}

            prepounce_r_targ.alignGlobalsTo(armature.r_hand_pin.targetNode.mimic().getGlobalMBasis()).project();
            rightInterpolator = new Interpolator(armature.r_hand_pin.targetNode, window.__tempVecPool);

            let J_Bip_C_Head_pin = armature.head_pin;
            J_Bip_C_Head_pin.target_threejs.position.set(-0.048201991083735636, 1.4857808131871846, 0.029283233212733198);
            J_Bip_C_Head_pin.target_threejs.quaternion.set(-0.24292338574302336, -0.04987885723340439, 0.026963677320800114, 0.9683869517737089);
            headStart.set(armature.head_pin.targetNode.origin());

            let J_Bip_C_Hips_pin = armature.hip_pin;
            J_Bip_C_Hips_pin.target_threejs.position.set(-0.015845857272104392, 1.0629170260866243, 0.17429608236224103);
            J_Bip_C_Hips_pin.target_threejs.quaternion.set(0.9917688869306138, 0, 0, 0.12804091110426974);

            let J_Bip_R_Foot_pin = armature.r_foot_pin;
            J_Bip_R_Foot_pin.target_threejs.position.set(0.13900366790462393, 0.43675138580707074, 0.08515916548568987);
            J_Bip_R_Foot_pin.target_threejs.quaternion.set(0.873397558546335, 0, 0, -0.48700791033134283);

            let J_Bip_L_Foot_pin = armature.l_foot_pin;
            J_Bip_L_Foot_pin.target_threejs.position.set(-0.19254600138696348, 0.3626079408726957, 0.12299547884725825);
            J_Bip_L_Foot_pin.target_threejs.quaternion.set(0.873397558546335, 0, 0, -0.48700791033134283);
        }

        async function loadModel(loadId, onloaded = (vrmscene) => { return vrmscene }) {
            let vrm = await loader.loadAsync(
                './vrmtests/testmodel.vrm',
                (xhr, otherParam) => { /*window.updateLoadStream(xhr, loadId)*/ },
                (error) => { window.notifyStreamError(error, loadId) }
            );
            scene.add(vrm.scene);
            return onloaded(vrm.scene, loadId);
        }

        const tempRot = new Rot(1,0,0,0);
        const prevBoxPos = new Vec3();
        window.clearRadius = 0.3;
        window.pounceScore = 0; 
        window.yourScore =0;
        window.leftScored = false;
        window.rightScored = false;
        let yourMostRecentPoint = Date.now();
        let pounceMostRecentPoint = Date.now();
        let mostRecentPoint = Date.now();
        window.hitboxhintid = -1;
        window.hitThresh = 0.05;
        window.flatPos = new Vec3();
        window.flatTarg = new Vec3();

        function maybePoint(currentTransform, isFinal) {
            let scored = false;
            flatPos.readFromTHREE(boxMesh.position);
            flatTarg.set(currentTransform.origin());
            flatPos.z = 0;
            flatTarg.z = 0;
            if(flatPos.dist(flatTarg) < hitThresh && Date.now()-mostRecentPoint > 500) {
                scoreHintMesh.visible = true;
                scoreHintMesh.position.copy(boxMesh.position);
                scoreHintMesh.updateMatrix();
                scoreHintMesh.material.color = new THREE.Color(1, 0, 0.8);
                window.clearTimeout(hitboxhintid);
                hitboxhintid = window.setTimeout(()=>{scoreHintMesh.material.color = new THREE.Color('blue'); scoreHintMesh.visible= false;}, 300);
                pounceScore++;
                pounceScoreContainer.innerText = pounceScore;
                scored = true;
                pounceMostRecentPoint = Date.now();
            } else if(isFinal && Date.now()-mostRecentPoint > 500) {
                scoreHintMesh.visible = true;
                scoreHintMesh.material.color = new THREE.Color(0, 1, 0);
                scoreHintMesh.position.copy(boxMesh.position);
                window.clearTimeout(hitboxhintid);
                hitboxhintid = window.setTimeout(()=>{scoreHintMesh.material.color = new THREE.Color('blue'); scoreHintMesh.visible= false;}, 300);
                yourScoreContainer.innerText = yourScore;
                yourMostRecentPoint = Date.now();
                yourScore++;
                scored = true;
            }
            mostRecentPoint = Math.max(pounceMostRecentPoint, yourMostRecentPoint);
            return scored;
        }

        function initLeftPounce() {
            if(!isMidPounce_left && !leftHandReturning) {   
                let pounceWith = armature.l_hand_pin;
                //leftGoal.setToIdentity();
                leftGoal.translate.readFromTHREE(boxMesh.position);
                leftGoal.rotation.setFromVecs(any_Vec3(0, 0, -1).normalize(), any_Vec3(1, 0, 0).normalize());
                //leftGoal.rotation.setFromVecs(any_Vec3(0,0,1), any_Vec3(0, 1, 0)); 
                //leftGoal.translate.readFromTHREE(boxMesh.position);
                let otherHandDist = leftGoal.translate.dist(armature.r_hand_pin.targetNode.origin());
                if(otherHandDist < window.clearRadius ) {
                   // console.log(`oldDist: ${otherHandDist.toFixed(4)}`); 
                    leftGoal.translate.sub(armature.r_hand_pin.targetNode.origin()).normalize().mult(clearRadius).add(armature.r_hand_pin.targetNode.origin());
                    otherHandDist = leftGoal.translate.dist(armature.r_hand_pin.targetNode.origin());
                    //console.log(`newDist: ${otherHandDist.toFixed(4)}`);
                }
                leftGoal.translate.z = -0.36;
                leftGoal.lazyRefresh();
                leftInterpolator.setGoal(leftGoal, (t, currentTransform)=>{
                    lastLeftPounce = Date.now();
                    leftHandResting = false;
                    leftHandReturning = false;
                    isMidPounce_left = true;

                }, (currentTransform) => {
                    isMidPounce_left = false;
                    leftHandReturning = false;
                    lastLeftPounce = Date.now(); 
                    armature.l_hand_pin.setPinWeight(0.5);
                    if(!leftScored ) {
                        leftScored = maybePoint(armature.l_hand_pin.forBone.trackedBy.getGlobalMBasis(), true);
                    }
                });
                leftScored = false;
                armature.l_hand_pin.setYPriority(0);
                armature.l_hand_pin.setXPriority(0.2);
                armature.l_hand_pin.setPinWeight(0.6);
                if(rightHandResting || rightHandReturning) {
                    armature.r_hand_pin.setPinWeight(0.1);
                }
                armature.r_hand_pin.setPinWeight(0.1);
                leftInterpolator.begin(120);
            }
        }
        
        function initRightPounce(timeThresh) {
            let pounceWith = armature.r_hand_pin;
            //rightGoal.setToIdentity();
            //tempRot.setFromVecs(any_Vec3(0,0,-1), any_Vec3(0, 1, 0)) 
            if(!isMidPounce_right && !rightHandReturning) {
                rightGoal.translate.readFromTHREE(boxMesh.position);
                let otherHandDist = rightGoal.translate.dist(armature.l_hand_pin.targetNode.origin());
                if(otherHandDist < window.clearRadius ) {
                    //console.log(`oldDist: ${otherHandDist.toFixed(4)}`);
                    rightGoal.translate.sub(armature.l_hand_pin.targetNode.origin()).normalize().mult(clearRadius).add(armature.l_hand_pin.targetNode.origin())
                    rightGoal.translate.dist(armature.l_hand_pin.targetNode.origin());
                    //console.log(`newDist: ${otherHandDist.toFixed(4)}`);
                }
                rightGoal.translate.z = -0.36;
                rightGoal.lazyRefresh();
                rightInterpolator.setGoal(rightGoal, (t, currentTransform)=>{
                    lastRightPounce = Date.now();                    
                    rightHandResting = false;
                    rightHandReturning = false;
                    isMidPounce_right = true;
                }, (currentTransform) => {
                    isMidPounce_right = false;
                    rightHandReturning = false;
                    lastRightPounce = Date.now();
                    if(!rightScored) {
                        rightScored = maybePoint(armature.r_hand_pin.forBone.trackedBy.getGlobalMBasis(), true);
                    }
                    
                });            
                armature.r_hand_pin.setYPriority(0);
                armature.r_hand_pin.setXPriority(0.2);
                armature.r_hand_pin.setPinWeight(0.6);
                rightScored = false;
                if(leftHandResting || leftHandReturning) {
                    armature.l_hand_pin.setPinWeight(0.1);
                }
                rightInterpolator.begin(120);
            }
        }
        function maybePounce() {
            let currTime = Date.now();
            if(currTime - unShy < shyMin) return;
            let boxPos = tempVec.readFromTHREE(boxMesh.position);
            let moveDist = boxPos.dist(prevBoxPos);
            let mouseVel = mouse.dist(prevMouse)/((currTime-lastMotion)/1000);
            if(mouseVel > 0) { 
                lastMotion = currTime;
                prevMouse.set(mouse);
                prevBoxPos.set(boxPos);
            }
            if(currTime - lastMotion < 1500 &&  mouseVel < 0.2 && boxMesh.position.z < itxPlane.position.z - 0.05) {
                //console.log(mouseVel);
                //console.log("can pounce");
                let pounceWith = null;
                let rhandDist = boxPos.dist(prepounce_r_targ.origin());
                let lhandDist = boxPos.dist(prepounce_l_targ.origin());
                let interHandDist = armature.l_hand_pin.targetNode.origin().dist(armature.r_hand_pin.targetNode.origin());                
                let pounceTimeThresh = pounceTimeMinThresh + (2*Math.random()*(pounceTimeAvgThresh - pounceTimeMinThresh));
                let lastPounce = Math.min(lastLeftPounce, lastRightPounce);
                if(currTime - lastPounce > pounceTimeThresh) {
                    if(lhandDist < rhandDist && lhandDist > clearRadius && !leftHandReturning && !isMidPounce_left) initLeftPounce();
                    if(rhandDist < lhandDist && rhandDist > clearRadius && !rightHandReturning && !isMidPounce_right) initRightPounce();
                }
            } else if (boxMesh.position.z <= itxPlane.position.z || currTime - lastMotion > 400) {
                if(!leftHandReturning && !leftHandResting && currTime - lastLeftPounce > 500) {
                    leftInterpolator.setGoal(prepounce_l_targ.getGlobalMBasis(), 
                        (...p) => {
                        }, 
                        (...p) => {
                            leftHandResting = true; 
                            leftHandReturning  = false;
                            isMidPounce_left = false;
                            armature.l_hand_pin.setYPriority(0.5);
                            unShy = Date.now();
                            shyMin = 1000;
                            leftScored = false;
                        });
                   
                        armature.r_hand_pin.setXPriority(0.5);
                    armature.r_hand_pin.setPinWeight(0.6);
                    leftHandReturning = true; 
                    isMidPounce_left = false;
                    leftHandResting = false;
                    leftInterpolator.begin(400);                    
                }
                if(!rightHandReturning && !rightHandResting && currTime - lastRightPounce > 500) {
                    rightInterpolator.setGoal(prepounce_r_targ.getGlobalMBasis(), 
                    (...p) => {}, 
                    (...p) => {
                        rightHandResting = true; 
                        isMidPounce_right = false;
                        rightHandReturning = false;
                        shyMin = 1000;
                        armature.r_hand_pin.setYPriority(0.5);
                        unShy = Date.now();
                        rightScored = false;
                    });
                    //
                    armature.r_hand_pin.setXPriority(0.5);
                    armature.r_hand_pin.setPinWeight(0.6);
                    
                    rightHandReturning = true;
                    isMidPounce_right = false; 
                    rightHandResting = false
                    rightInterpolator.begin(400);
                }
            }
            leftInterpolator.tick(true);
            rightInterpolator.tick(true);
        }

        window.addEventListener('mousemove', (event) => {
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }, false);

        window.render = function () {
            mouseCaster.setFromCamera(mouse, camera);
            //pointToward(planeShadow, camera.position);
            itxBound.visible=false; 
            itxPlane.visible=false;
            let itx = mouseCaster.intersectObjects([itxBound, itxPlane]);
            itxBound.visible = false;
            itxPlane.visible = false;
            window.renderer.clear();
            camera.layers.set(0);
            if(itx.length>0 && lookat) {
                boxMesh.position.copy(itx[0].point);
                maybePounce();
                glare(armature, boxMesh.position, 0.2, downadjust/*, (leftHandResting && rightHandResting) || (isMidPounce_left || isMidPounce_right)*/);
            }            
            window.renderer.render(scene, camera);
            window.renderer.clearDepth();
            const currentBackground = scene.background;
            const currentFog = scene.fog;
            scene.background = null;
            scene.fog = null;
            camera.layers.set(1);
            window.renderer.render(scene, camera);
            scene.background = currentBackground;
            scene.fog = currentFog;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            render();
        }

        function animate() {
            window.frameCount++;
            requestAnimationFrame(animate);
            window.armature.solve(undefined, undefined, undefined, undefined, undefined, undefined, window.frameCount);
            render();
        }

        const headStart = new Vec3();
        const tempVec = new Vec3();
        const tempVec2 = new Vec3();
        const downadjust = new Vec3(0, 0.1, -1).normalize();

        function glare(char, point, rate, heading, lean = true) {
            let targNode = char.c_head.getIKPin().targetNode;
            tempVec.set(targNode.getGlobalMBasis().yHeading);
            tempVec2.setComponents(0.008, 0.977, -0.214).normalize();
            
            let temprot = Rot.fromVecs(tempVec, tempVec2);
            Rot.fromSlerp(Rot.IDENTITY, temprot, rate, temprot);

            targNode.rotateByGlobal(temprot);//.updateGlobal().project();
            targNode.project();

            //tempVec.set(targNode.getGlobalMBasis().zHeading).mult(-1);
            targNode.setVecToGlobalOf(heading, tempVec).sub(targNode.origin())
            //tempVec.set(heading);//.mult(-1);
            tempVec2.readFromTHREE(point).sub(targNode.origin()).normalize();
            tempVec2.z = Math.min(tempVec2.z, targNode.origin().z-0.01);
            temprot = Rot.fromVecs(tempVec, tempVec2);
            targNode.rotateByGlobal(Rot.fromSlerp(Rot.IDENTITY, temprot, rate, temprot));
            targNode.updateGlobal();
            if(lean) {
                tempVec.set(targNode.origin());
                tempVec2.readFromTHREE(point);
                tempVec.lerp(tempVec2, rate*.5);
                tempVec2.set(headStart);
                tempVec.z = headStart.z;
                targNode.translateTo(tempVec2.lerp(tempVec, 0.8));
            }
            targNode.project();
        }

        function pointToward(node, point, heading = node.getGlobalMBasis().zHeading) {
            tempVec.readFromTHREE(point);
            tempVec.sub(node.origin()).normalize();
            node.rotateByGlobal(Rot.fromVecs(heading,tempVec));
            node.project();
        }

        init();
    </script>
    
    <style>
        body {
            margin: 0;
        }

        canvas {
            display: block;
        }
        div#pounce-score {
            position: absolute;
            bottom: 2em;
            right: 0px;
            font-size: 2em;
            font-family: cursive;
            color: #ff00ff;
            filter: drop-shadow(0px 0px 2px black);
        }
        div#your-score {
            position: absolute;
            bottom: 2em;
            font-size: 2em;
            font-family: cursive;
            color: rgb(0, 255, 0);
            filter: drop-shadow(0px 0px 2px black);
        }
    </style>
</body>