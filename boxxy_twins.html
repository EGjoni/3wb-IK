<!DOCTYPE html>
<html>

<head>
    <title>Three.js Skeleton Interaction</title>

    <script type="importmap">
        {
            "imports": {
                "three": "./js/three/three.module.js",
                "orbitControls": "./js/three/jsm/OrbitControls.js",
                "transformControls": "./js/penziltransform.js",
                "gltf" : "./js/three/jsm/GLTFLoader.js",
                "convexGeo": "./js/EWBIK/util/mathdump/ConvexHull.js",
                "vrm" : "./js/three/jsm/three-vrm.module.js",
                "mesh-bvh" : "./js/toys/Boxxy/modules/three-mesh-bvh/index.module.js",
                "enviro" : "./js/environment.js"
              }
        }
    </script>

    <script>
        const keyState = {};
        function updateKeyState(event) {
            const keyCode = event.code;
            if (event.type === 'keydown') {
                keyState[keyCode] = true;
            } else if (event.type === 'keyup') {
                keyState[keyCode] = false;
            }
        }

        document.addEventListener('keydown', updateKeyState);
        document.addEventListener('keyup', updateKeyState);


        function isKeyPressed(keyCode) {
            return !!keyState[keyCode];
        }
    </script>
</head>

<body>
    <div class="clack" style="position:absolute; background:rgba(0, 0, 0, 0.329); color:white; font-size:1.5em;">WASD to
        move. Drag to orbit.</div>
    <!--<script type="module" src="./js/UIelements.js"></script>-->
    <script src="js/sceneStuff.js"></script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from "./js/three/jsm/OrbitControls.js";
        import { TransformControls } from 'transformControls';
        import {mergeGeometries} from "./js/three/utils/BufferGeometryUtils.js";
        import {computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'mesh-bvh';
        import { Boxxy } from "./js/toys/Boxxy/Boxxy.js";
        import { GLTFLoader } from 'gltf';
        import { VRMLoaderPlugin } from 'vrm';
        import { EWBIK } from "./js/EWBIK/EWBIK.js";
        import { IKNode, TrackingNode } from "./js/EWBIK/util/nodes/IKNodes.js";
        import { IKPin } from "./js/EWBIK/betterbones/IKpin.js";
        import { Rest, Twist, Kusudama } from "./js/EWBIK/betterbones/Constraints/ConstraintStack.js";
        import { Vec3, Vec3Pool } from "./js/EWBIK/util/vecs.js";
        import { Rot } from "./js/EWBIK/util/Rot.js";
        import {initWolfGirlShortcuts, initWolfGirlConstraints, initWolfGirlCosmeticPins} from "./js/toys/rigs/wolfgirl_vrm.js";
        
        window.Rest = Rest;
        window.Vec3 = Vec3;
        window.OrbitControls = OrbitControls;
        window.TransformControls = TransformControls;
        window.IKNode = IKNode;
        window.TrackingNode = TrackingNode;
        window.IKPin = IKPin;
        window.axeshelper = new THREE.AxesHelper(1);
        window.hipaxeshelper = new THREE.AxesHelper(1);
        window.THREE = THREE;


        // Scene, camera, and renderer setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.1, 1000);
        window.camera = camera;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        window.renderer = renderer;
        renderer.setClearColor(0x000000, 0);
        const hemisphereLight = new THREE.HemisphereLight(0x333866, 0x000000, 4.1);
        camera.position.z = -5; camera.position.y = 6;
        renderer.autoClear = false;
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        scene.add(hemisphereLight);
        renderer.setClearColor(0x000000, 0);
        scene.background = new THREE.Color(0x101577);
        //scene.background = new THREE.Color(0x000000);
        const dirLight = new THREE.DirectionalLight(0x775522, 1);
        const plight = new THREE.PointLight();
        plight.power = 5;
        plight.decay = 0.15;
        window.plight = plight;
        //dirLight.color.setHSL( 0.1, 1, 0.95 );
        dirLight.position.set(1, 1.75, -1);
        dirLight.position.multiplyScalar(1);
        //scene.add(dirLight);
        scene.add(plight);



        //let orbitControls = new OrbitControls(camera, renderer.domElement);

        /*
        orbitControls.target.y = 1;
        orbitControls.enableDampening = true;
        orbitControls.dampingFactor = 0.4;
        window.orbitControls = orbitControls;
        orbitControls.update();*/
        let boxxy = null; //new Boxxy(0.87, 0.87);
        window.contextBone = null;
        window.meshLayer = 0;
        window.boneLayer = 1;
        window.scene = scene;
        window.boxxy = boxxy;
        window.frrate = 1 / 60;
        window.frtime = window.frrate * 1000;
        window.lookat=true;
        const loader = new GLTFLoader();
        const clock = new THREE.Clock();

        async function init() {
            randCubes(1, 3, 1, 0.9, 16)
            //groundPlane();
            loader.register((parser) => {
                return new VRMLoaderPlugin(parser);
            });
            window.armature = await loadModel({ x: 0, y: 0, z: 0 }, 0, ikify);
            window.follower = await loadModel({ x: 0, y: 0, z: 0 }, 0, ikify);
            let lhand = window.armature.bonetags["J_Bip_L_Hand"];
            lhand.rotateZ(1.5);
            lhand.rotateX(0.5);
            window.leaderHand = new IKPin(lhand);
            addSceneArmature(window.armature);
            initControls(THREE, renderer);
            armature.hip_pin.target_threejs.attach(leaderHand.target_threejs);
            leaderHand.targetNode.setParent(armature.hip_pin.targetNode);
            leaderHand.targetNode.translateTo(window.armature.hipPinNode.origin());
            leaderHand.targetNode.translateByGlobal(noPool.new_Vec3(-0.3, 0.2, 0)).project();
            armature.r_arm_upp.rotateZ(-1);

            follower.hip_pin.setPinWeight(0.1);
            follower.hip_pin.setDepthFalloff(0.95);
            follower.head_pin.setPinWeight(0.2);
            follower.l_arm_upp.rotateZ(1);
            let frhand = window.follower.bonetags["J_Bip_R_Hand"];
            frhand.rotateZ(-1.5);
            frhand.rotateX(+0.5);
            let follower_hand = new IKPin(frhand);
            follower_hand.targetNode.translateTo(leaderHand.forBone.trackedBy.origin()).project();
            follower_hand.targetNode.toTrack.position.z += 0.05;
            follower_hand.targetNode.toTrack.rotateX(-0.5); follower_hand.targetNode.mimic();
            leaderHand.forBone.attach(follower_hand.targetNode.toTrack);

            //leaderHand.targetNode.toTrack.attach(follower_hand.targetNode.toTrack);
            //follower_hand.targetNode.setParent(leaderHand.targetNode);
            follower_hand.targetNode.setParent(leaderHand.forBone.trackedBy);
            follower_hand.targetNode.toTrack.position.y -= 0.05; follower_hand.targetNode.mimic();
            armature.boxxy.pool.finalize();
            clock.start();
            //window.bbox = new THREE.BoxHelper(groundGeos, 0xffff00 );
            //window.bbox.update();
            orbitControls.maxDistance = 10;
            orbitControls.minDistance = 8;
            camera.position.y = armature.c_head.position.y + 1;
            window.frhand = frhand;
            frhand.add(plight);
            scene.attach(plight);
            plight.position.y += 1;
            frhand.attach(plight);
            animate();
        }

        function ikify(inst) {
            let armature = new EWBIK(inst.scene.children[0]);
            armature.setDefaultIterations(10);
            armature.setDampening(1);
            armature.c_hips = armature.bonetags["J_Bip_C_Hips"];
            //snip the root bone (make it shorter).
            armature.c_hips.parent.position.y = armature.c_hips.position.y - 0.01;
            armature.c_hips.position.y = 0.01;
            armature.makeBoneMesh(armature.c_hips.parent, armature.c_hips.parent.boneRadius);
            initPrettyBones(armature);
            initHumanoidRestConstraints(armature);
            makePinsList(1, armature.armatureObj3d, armature, false, false);
            updateGlobalBoneLists();
            initIK(armature);
            //initPrettyBones(armature);
            armature.regenerateShadowSkeleton(true);
            return armature;
        }

        function initHumanoidRestConstraints(armature) {

            initWolfGirlShortcuts(armature);
            initWolfGirlConstraints(armature, true);

            armature.head_pin = new IKPin(armature.c_head);
            armature.hip_pin = new IKPin(armature.c_hips);
            armature.r_foot_pin = new IKPin(armature.bonetags["J_Bip_R_Foot"]);
            armature.l_foot_pin = new IKPin(armature.bonetags["J_Bip_L_Foot"]);

            window.hipsTracker = armature.hip_pin.target_threejs;
            armature.hipsTracker = window.hipsTracker;
            armature.hipPinNode = armature.hip_pin.targetNode;
            armature.hip_pin.setPinWeight(0.1);
            armature.hip_pin.setDepthFalloff(0.9);
            armature.head_pin.setPinWeight(0.4);
            armature.hip_pin.alignToBone();
            armature.head_pin.alignToBone();
            armature.head_pin.target_threejs.position.y += 0.2;
            armature.head_pin.targetNode.mimic();
            armature.hipsTracker.attach(armature.head_pin.target_threejs);
            armature.head_pin.targetNode.ensure();

            armature.boxxy = new Boxxy(
                0.95,
                armature.c_hips,
                armature.bonetags["J_Bip_L_Foot"],
                armature.l_leg_upp,
                armature.bonetags["J_Bip_R_Foot"],
                armature.r_leg_upp,
                new Vec3Pool(3000)
            );

            //armature.boxxy.hips.position.y *= 0.8;
            armature.boxxy.addTo(scene, intersectables);

            armature.boxxy.hips.position.copy(armature.hip_pin.target_threejs.position);
            armature.boxxy.hipsNode.mimic();
            armature.boxxy.hips.attach(armature.hip_pin.target_threejs);
            armature.visible = false;


            armature.boxxy.right_foot.foot.add(armature.r_foot_pin.target_threejs);
            armature.boxxy.left_foot.foot.add(armature.l_foot_pin.target_threejs);
            //armature.boxxy.hipClearance -=0.05;
            armature.l_foot_pin.alignToBone();
            armature.r_foot_pin.alignToBone();
            armature.l_foot_pin.targetNode.translateByGlobal(new Vec3(0, 0.1, 0));//account for the platform boots with the furr
            armature.r_foot_pin.targetNode.translateByGlobal(new Vec3(0, 0.1, 0));//account for the platform boots with the furr
            armature.l_foot_pin.targetNode.project();
            armature.r_foot_pin.targetNode.project();

            armature.boxxy.preAlign();

            initWolfGirlCosmeticPins(armature);

            window.goahead = true;
            window.dowalk = true;

        }

        //const groundGeosMat = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
        const groundGeosMat = new THREE.MeshLambertMaterial({ color: 0x444444 });
        const groundGeos = [];//new THREE.Group();
        const intersectables = [];
        window.groundMesh = null;
        //scene.add(groundGeos);
        /*function groundPlane() {
            let planeGeo = new THREE.BoxGeometry(10, 0.01, 10);
            let gp = new THREE.Mesh(planeGeo, intersectables);
            groundGeos.push(gp);
            scene.add(gp);
        }*/

        window.groundMesh = null;
        function randCubes(heightDelta, sizeDelta, spacing, angleDelta, area) {
            let maxdim = spacing * 5;
            let minDim = spacing/2;
            for(let x = 0; x < area; x += spacing) {
                for(let z = 0; z < area; z += spacing) {
                    let minx = Math.max(Math.random()*sizeDelta*maxdim, minDim);
                    let minz = Math.max(Math.random()*sizeDelta*maxdim, minDim);
                    let boxGeo = new THREE.SphereGeometry(Math.max(minDim, minDim+Math.random()*sizeDelta), 16, 16); 
                    //let boxGeo = new THREE.BoxGeometry(minx, 1/*Math.random()*minDim*heightDelta*/, minz);//new THREE.DodecahedronGeometry(minx, 1);//, Math.random()*minDim*heightDelta); //
                    //let boxMesh = new THREE.Mesh(boxGeo, groundGeosMat);

                    /*boxGeo.position.x = x; boxMesh.position.z = z;
                    let xd = Math.abs(x-(area/2));
                    let zd = Math.abs(z-(area/2));
                    boxGeo.rotateX(-0.15+(.5*angleDelta - Math.random()*angleDelta)*(2*(xd+zd)/(area)));
                    boxGeo.rotateY((.5*angleDelta - Math.random()*angleDelta)*(2*(xd+zd)/(area)));
                    boxGeo.rotateZ((.5*angleDelta - Math.random()*angleDelta)*(2&(xd+zd)/(area)));
                    boxGeo.material.side = 0;*/
                    groundGeos.push(boxGeo);
                    //window.testMesh = new THREE.Mesh(boxGeo, groundGeosMat);
                    //scene.add(testMesh);
                    boxGeo.translate(x-area/2, -1-(Math.random()*heightDelta), z-area/2);
                    //scene.add(boxMesh)
                }
            }
            let groundGeo = mergeGeometries(groundGeos, false);
            window.groundMesh = new THREE.Mesh( groundGeo, groundGeosMat);
            intersectables.push(groundMesh);
            groundGeo.computeBoundsTree();
            scene.add(groundMesh);
            
            /**groundGeos.position.x = -area/2;
            groundGeos.position.z = -area/2;
            groundGeos.position.y = -2;*/
        }


        function delayAnimate() {
            window.setTimeout(animate, window.frtime);
        }

        async function loadModel(position, loadId, onloaded) {
            let vrm = await loader.loadAsync(
                './vrmtests/testmodel.vrm',
                (xhr, otherParam) => { },
                (error) => { window.notifyStreamError(error, loadId) }
            );
            vrm.scene.updateMatrixWorld();
            scene.add(vrm.scene);
            scene.traverse((object) => {
                if (object.isSkinnedMesh) {
                    object.frustumCulled = false;
                }
            });
            let rootBone1 = vrm.scene.children[0];
            rootBone1.position.set(position.x, position.y, position.z);
            return onloaded(vrm, loadId);
        }
        const forwardVec = new Vec3(0, 0, 1);
        const leftVec = new Vec3(1, 0, 0);
        window.forwardVec = forwardVec; window.leftVec = leftVec;
        const tempVec = new Vec3(1, 0, 0);
        const tempVec2 = new Vec3(1, 0, 0);
        const temp3v = new THREE.Vector3(0, 0, 0);
        window.framecount = 0;
        window.physicsUpdateCount = 0;
        function animate() {
            requestAnimationFrame(delayAnimate);
            armature.c_hips.getWorldPosition(temp3v);
            tempVec.readFromTHREE(temp3v);
            //orbitControls.target.copy(boxxy.hips.position);
            forwardVec.readFromTHREE(orbitControls.target);
            forwardVec.lerp(tempVec, 0.05);
            forwardVec.writeToTHREE(orbitControls.target);
            orbitControls.update();
            let updateCount = clock.getDelta() / window.frrate;
            tempVec.readFromTHREE(camera.position);
            forwardVec.readFromTHREE(orbitControls.target);
            forwardVec.sub(tempVec);
            forwardVec.y = 0;
            forwardVec.normalize();
            tempVec.setComponents(0, 1, 0);
            forwardVec.cross(tempVec, leftVec);
            leftVec.normalize();

            /*if(window.framecount % 60) {
                console.log(boxxy.hips.position.y.toFixed(5));
                //console.log(`physics updates: ${window.physicsUpdateCount} in ${window.framecount} frames`);
            }*/
            window.framecount++;

            for (let i = 0; i < updateCount; i++) {
                armature.boxxy.controlledUpdate(forwardVec, leftVec, i == 0);
                if (window.dowalk) {
                    window.follower.boxxy.inferredUpdate(window.follower.c_hips.trackedBy.origin());
                }
                window.physicsUpdateCount++;
            }

            if (window.goahead) {
                leaderHand.targetNode.translateTo(armature.c_hips.trackedBy.origin().lerp(follower.c_hips.trackedBy.origin(), 0.5)).project();
                if(window.lookat) {
                    glare(armature, 0.05);
                    glare(follower, 0.15);
                }

                window.armature.solve();
                window.follower.solve();
            }
            //console.log(acceleration);
            window.render();
        }

        function glare(char, rate) {
            tempVec.set(char.c_head.getIKPin().targetNode.getGlobalMBasis().yHeading);
            tempVec2.setComponents(0.008, 0.977, -0.214).normalize();
            let temprot = Rot.fromVecs(tempVec, tempVec2);
            Rot.fromSlerp(Rot.IDENTITY, temprot, rate, temprot);

            char.c_head.getIKPin().targetNode.rotateByGlobal(temprot);//.updateGlobal().project();
            char.c_head.getIKPin().targetNode.project();

            tempVec.set(char.c_head.getIKPin().targetNode.getGlobalMBasis().zHeading).mult(-1);
            tempVec2.readFromTHREE(camera.position).sub(char.c_head.getIKPin().targetNode.origin()).normalize();
            temprot = Rot.fromVecs(tempVec, tempVec2);
            char.c_head.getIKPin().targetNode.rotateByGlobal(Rot.fromSlerp(Rot.IDENTITY, temprot, rate, temprot));
            char.c_head.getIKPin().targetNode.updateGlobal().project();
        }
        init();
        window.camera = camera;

        window.render = function () {
            camera.layers.set(0);
            const currentBackground = scene.background;
            const currentFog = scene.fog;

            renderer.render(scene, camera);
            /*renderer.clearDepth();
            
            scene.background = null;
            scene.fog = null;
            camera.layers.set(1);
            renderer.render(scene, camera);
            scene.background = currentBackground;
            scene.fog = currentFog;*/

        }
        //animate();

    </script>
    <style>
        body {
            margin: 0;
        }

        canvas {
            display: block;
        }
    </style>
</body>