<!DOCTYPE html>
<html>
<head>
    <title>Three.js Skeleton Interaction</title>

    <script type="importmap">
        {
            "imports": {
                "three": "./js/three/three.module.js",
                "orbitControls": "./js/three/jsm/OrbitControls.js",
                "transformControls": "./js/penziltransform.js",
                "gltf" : "./js/three/jsm/GLTFLoader.js",
                "convexGeo": "./js/EWBIK/util/mathdump/ConvexHull.js",
                "vrm" : "./js/three/jsm/three-vrm.module.js",
                "enviro" : "./js/environment.js"
              }
        }
    </script>
    
    <script> 
        const keyState = {};
        function updateKeyState(event) {
            const keyCode = event.code;
            if (event.type === 'keydown') {
                keyState[keyCode] = true;
            } else if (event.type === 'keyup') {
                keyState[keyCode] = false;
            }
        }

        document.addEventListener('keydown', updateKeyState);
        document.addEventListener('keyup', updateKeyState);
        

        function isKeyPressed(keyCode) {
            return !!keyState[keyCode];
        }
    </script>
</head>
<body>
    <!--<script type="module" src="./js/UIelements.js"></script>-->
    <script src="js/sceneStuff.js"></script>
    <script type = "module"> 
        import * as THREE from 'three';
        import {OrbitControls} from "./js/three/jsm/OrbitControls.js";
        import { TransformControls } from 'transformControls';
        import {Boxxy} from "./js/toys/Boxxy/Boxxy.js";
        import { GLTFLoader } from 'gltf';
        import { VRMLoaderPlugin } from 'vrm';
        import { EWBIK } from "./js/EWBIK/EWBIK.js";
        import { IKNode, TrackingNode } from "./js/EWBIK/util/nodes/IKNodes.js";
        import { IKPin } from "./js/EWBIK/betterbones/IKpin.js";
        import { Rest, Twist, Kusudama } from "./js/EWBIK/betterbones/Constraints/ConstraintStack.js";
        import {Vec3, Vec3Pool} from "./js/EWBIK/util/vecs.js";
        window.Rest = Rest;
        window.OrbitControls = OrbitControls;
        window.TransformControls = TransformControls;
        window.IKNode = IKNode;
        window.TrackingNode = TrackingNode;
        window.IKPin = IKPin;
        window.axeshelper = new THREE.AxesHelper(1);
        window.hipaxeshelper = new THREE.AxesHelper(1);
        window.THREE = THREE;
        

        // Scene, camera, and renderer setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
        window.camera = camera;
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        window.renderer = renderer;
        renderer.setClearColor(0x000000, 0);
        const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x000000, 0.5);
        camera.position.z = -5; camera.position.y = 6;
        renderer.autoClear = false;
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        scene.add(hemisphereLight);
        scene.background = new THREE.Color(0x772200);
        const dirLight = new THREE.DirectionalLight( 0x775522, 1 );
        //dirLight.color.setHSL( 0.1, 1, 0.95 );
        dirLight.position.set( 1, 1.75, -1 );
        dirLight.position.multiplyScalar( 1 );
        scene.add( dirLight );
        


        //let orbitControls = new OrbitControls(camera, renderer.domElement);
        /*orbitControls.maxDistance = 8;
        orbitControls.minDistance = 4;
        orbitControls.target.y = 1;
        orbitControls.enableDampening = true;
        orbitControls.dampingFactor = 0.4;
        window.orbitControls = orbitControls;
        orbitControls.update();*/
        let boxxy = null; //new Boxxy(0.87, 0.87);
        window.contextBone = null;
        window.meshLayer = 0;
        window.boneLayer = 1;
        window.scene = scene;
        window.boxxy = boxxy;
        window.frrate = 1/60;
        window.frtime = window.frrate*1000;
        const loader = new GLTFLoader();
        const clock = new THREE.Clock();
       
        async function init() {
            randCubes(0.8, 1.1, 2, 0.3, 10);
            //groundPlane();
            loader.register((parser) => {
                return new VRMLoaderPlugin(parser);
            });
            window.armature = await loadModel({ x: 0, y: 0, z: 0 }, 0, ikify);
            addSceneArmature(window.armature);
            initControls(THREE, renderer);
            clock.start();
            //window.bbox = new THREE.BoxHelper(groundCubes, 0xffff00 );
            //window.bbox.update();
            animate();
        }

        function ikify(inst) {
            let armature = new EWBIK(inst.scene.children[0]);            
            armature.setDefaultIterations(10);
            armature.setDampening(1);
            armature.c_hips = armature.bonetags["J_Bip_C_Hips"];
            //snip the root bone (make it shorter).
            armature.c_hips.parent.position.y = armature.c_hips.position.y -0.01;
            armature.c_hips.position.y = 0.01;
            armature.makeBoneMesh(armature.c_hips.parent, armature.c_hips.parent.boneRadius);
            initPrettyBones(armature);
            initHumanoidRestConstraints(armature);
            makePinsList(1, armature.armatureObj3d, armature, false, false);
            updateGlobalBoneLists();
            initIK(armature);
            //initPrettyBones(armature);
            armature.regenerateShadowSkeleton();
            return armature;
        }

        function initHumanoidRestConstraints(armature) {

            armature.l_arm_upp = armature.bonetags["J_Bip_L_UpperArm"];
            armature.r_arm_upp = armature.bonetags["J_Bip_R_UpperArm"];
            armature.l_arm_lower = armature.bonetags["J_Bip_L_LowerArm"];
            armature.r_arm_lower = armature.bonetags["J_Bip_R_LowerArm"];
            armature.l_leg_upp = armature.bonetags["J_Bip_L_UpperLeg"];
            armature.r_leg_upp = armature.bonetags["J_Bip_R_UpperLeg"];
            armature.l_leg_lower = armature.bonetags["J_Bip_L_LowerLeg"];
            armature.r_leg_lower = armature.bonetags["J_Bip_R_LowerLeg"];
            armature.c_head = armature.bonetags["J_Bip_C_Head"];
            armature.c_hips = armature.bonetags["J_Bip_C_Hips"];
            armature.c_chest = armature.bonetags["J_Bip_C_Chest"];
            armature.r_foot = armature.bonetags["J_Bip_R_Foot"];
            armature.l_foot = armature.bonetags["J_Bip_L_Foot"];
            armature.upper_chest = armature.bonetags["J_Bip_C_UpperChest"];

            //override the autoinferred orientation for the legs because this rig has weird tassles that throw it off
            armature.setInternalOrientationFor(armature.r_leg_lower, armature.r_foot.position);
            armature.setInternalOrientationFor(armature.l_leg_lower, armature.l_foot.position);

           
            let rootrest = new Rest(armature.c_hips.parent);
            rootrest.setPainfulness(0.99);
            rootrest.setStockholmRate(0.99);
            let hipRest = new Rest(armature.c_hips);
            hipRest.setPainfulness(0.8);
            hipRest.setStockholmRate(0.85);

            new Kusudama(armature.bonetags["J_Bip_L_UpperLeg"], (cnstrt, bone) => bone == contextBone, "Kusudama for J_Bip_L_UpperLeg", armature.stablePool)
            .addLimitConeAtIndex(0, armature.stablePool.any_Vec3(-0.2505336783387944, -0.2645716928861982, -0.9312543666159987), 0.48411).parentKusudama
            .addLimitConeAtIndex(1, armature.stablePool.any_Vec3(-0.3143631992559614, -0.7667395103803937, -0.5597198425776874), 0.69579).parentKusudama
            .addLimitConeAtIndex(2, armature.stablePool.any_Vec3(0, -0.9578262852211515, 0.28734788556634544), 0.45589);
            new Twist(armature.bonetags["J_Bip_L_UpperLeg"], 0.70009, undefined, 
                armature.stablePool.any_Vec3(1.9041464198590058e-8, -0.9996624984362763, 0.025978630066681115), 
                0, (cnstrt, bone) => bone == contextBone,
                "Twist for J_Bip_L_UpperLeg", armature.stablePool);


            new Kusudama(armature.bonetags["J_Bip_L_LowerLeg"], (t, b) => b==contextBone, "Kusudama for J_Bip_L_LowerLeg", armature.stablePool)
                .addLimitConeAtIndex(0, armature.stablePool.any_Vec3(0, -0.8884406832782645, 0.165822952043333464), 0.1).parentKusudama
                .addLimitConeAtIndex(1, armature.stablePool.any_Vec3(0, 0.7518876717414535, 0.6592912323724746), 0.1);
            new Twist(armature.bonetags["J_Bip_L_LowerLeg"], 0.34729, undefined, 
                            armature.stablePool.any_Vec3(0, -0.9987182064357158, 0.050615651075934326), 
                            0, (cnstrt, bone) => bone == contextBone,
                            "Twist for J_Bip_L_LowerLeg", armature.stablePool);

            new Kusudama(armature.bonetags["J_Bip_L_Foot"], (t, b) => b==contextBone, "Kusudama for J_Bip_L_Foot", armature.stablePool)
            .addLimitConeAtIndex(0, armature.stablePool.any_Vec3(0, -0.5256465905493974, -0.8507030397522946), 0.75224);
            new Twist(armature.bonetags["J_Bip_L_Foot"], 1.78672, undefined, 
                            armature.stablePool.any_Vec3(0, -0.5256465905493974, -0.8507030397522946), 
                            6.19399, (cnstrt, bone) => bone == contextBone,
                            "Twist for J_Bip_L_Foot", armature.stablePool);

            new Kusudama(armature.bonetags["J_Bip_R_UpperLeg"], (cnstrt, bone) => bone == contextBone, "Kusudama for J_Bip_R_UpperLeg", armature.stablePool)
            .addLimitConeAtIndex(0, armature.stablePool.any_Vec3(0.2505336783387944, -0.2645716928861982, -0.9312543666159987), 0.48411).parentKusudama
            .addLimitConeAtIndex(1, armature.stablePool.any_Vec3(0.3143631992559614, -0.7667395103803937, -0.5597198425776874), 0.69579).parentKusudama
            .addLimitConeAtIndex(2, armature.stablePool.any_Vec3(0, -0.9578262852211515, 0.28734788556634544), 0.45589);
            new Twist(armature.bonetags["J_Bip_R_UpperLeg"], 0.70009, undefined, 
                armature.stablePool.any_Vec3(-1.9041464198590058e-8, -0.9996624984362763, 0.025978630066681115), 
                0, (cnstrt, bone) => bone == contextBone,
                "Twist for J_Bip_R_UpperLeg", armature.stablePool);


            new Kusudama(armature.bonetags["J_Bip_R_LowerLeg"], (t, b) => b==contextBone, "Kusudama for J_Bip_R_LowerLeg", armature.stablePool)
                .addLimitConeAtIndex(0, armature.stablePool.any_Vec3(0, -0.8884406832782645, 0.165822952043333464), 0.1).parentKusudama
                .addLimitConeAtIndex(1, armature.stablePool.any_Vec3(0, 0.7518876717414535, 0.6592912323724746), 0.1);
            new Twist(armature.bonetags["J_Bip_R_LowerLeg"], 0.34729, undefined, 
                            armature.stablePool.any_Vec3(0, -0.9987182064357158, 0.050615651075934326), 
                            0, (cnstrt, bone) => bone == contextBone,
                            "Twist for J_Bip_R_LowerLeg", armature.stablePool);

            new Kusudama(armature.bonetags["J_Bip_R_Foot"], (t, b) => b==contextBone, "Kusudama for J_Bip_R_Foot", armature.stablePool)
            .addLimitConeAtIndex(0, armature.stablePool.any_Vec3(0, -0.5256465905493974, -0.8507030397522946), 0.75224);
            new Twist(armature.bonetags["J_Bip_R_Foot"], 1.78672, undefined, 
                            armature.stablePool.any_Vec3(0, -0.5256465905493974, -0.8507030397522946), 
                            6.19399, (cnstrt, bone) => bone == contextBone,
                            "Twist for J_Bip_R_Foot", armature.stablePool);
            /*armature.r_foot.getConstraint().disable();
            armature.l_foot.getConstraint().disable();
            armature.l_leg_lower.getConstraint().disable();
            armature.r_leg_lower.getConstraint().disable();
            armature.r_leg_upp.getConstraint().disable();
            armature.l_leg_upp.getConstraint().disable();*/


            for (let b of armature.bones) {
                if (b.getConstraint() == null) {
                    let restconst = new Rest(b);
                }
            }

            armature.head_pin = new IKPin(armature.c_head);
            armature.hip_pin = new IKPin(armature.c_hips);
            armature.r_foot_pin = new IKPin(armature.bonetags["J_Bip_R_Foot"]);
            armature.l_foot_pin = new IKPin(armature.bonetags["J_Bip_L_Foot"]);

            window.hipsTracker = armature.hip_pin.target_threejs;  
            armature.hipsTracker  = window.hipsTracker;
            armature.hipPinNode = armature.hip_pin.targetNode;
            armature.hip_pin.setPinWeight(0.1); 
            armature.hip_pin.setDepthFalloff(0.9);
            armature.head_pin.setPinWeight(0.4);
            armature.hip_pin.alignToBone();
            armature.head_pin.alignToBone();
            armature.head_pin.target_threejs.position.y += 0.2;
            armature.head_pin.targetNode.mimic();
            armature.hipsTracker.attach(armature.head_pin.target_threejs);
            armature.head_pin.targetNode.ensure();

            boxxy = new Boxxy(
                0.95,
                armature.c_hips, 
                armature.bonetags["J_Bip_L_Foot"],
                armature.l_leg_upp,
                armature.bonetags["J_Bip_R_Foot"],
                armature.r_leg_upp,
                new Vec3Pool(3000)
                );
            
            //boxxy.hips.position.y *= 0.8;
            boxxy.addTo(scene, groundCubes); 
            
            boxxy.hips.position.copy(armature.hip_pin.target_threejs.position);           
            boxxy.hipsNode.mimic();
            boxxy.hips.attach(armature.hip_pin.target_threejs);            
            window.boxxy = boxxy; 
            armature.visible = false;

            
            boxxy.right_foot.foot.add(armature.r_foot_pin.target_threejs);
            boxxy.left_foot.foot.add(armature.l_foot_pin.target_threejs);
            //boxxy.hipClearance -=0.05;
            armature.l_foot_pin.alignToBone();
            armature.r_foot_pin.alignToBone();
            armature.l_foot_pin.targetNode.translateByGlobal(new Vec3(0, 0.1, 0));//account for the platform boots with the furr
            armature.r_foot_pin.targetNode.translateByGlobal(new Vec3(0, 0.1, 0));//account for the platform boots with the furr
            armature.l_foot_pin.targetNode.project();
            armature.r_foot_pin.targetNode.project();
            
            //armature.head_pin.target_threejs.add(axeshelper);
            //armature.hip_pin.target_threejs.add(hipaxeshelper);
            //armature.l_foot_pin.targetupdateWorldMatrix(); armature.r_foot_pin.updateWorldMatrix();
            
            boxxy.showHips(); boxxy.showFeet();
            boxxy.pool.finalize();
            //armature.l_foot_pin.ensure(); armature.r_foot_pin.ensure(); armature.hip_pin.ensure(); armature.head_pin.ensure();
            boxxy.preAlign();
            window.goahead = true;
            window.dowalk= true;
                     
        }
        
        //const groundCubesMat = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
        const groundCubesMat = new THREE.MeshLambertMaterial({color: 0x444444});
        const groundCubes = [];//new THREE.Group();
        window.groundCubes = groundCubes;
        //scene.add(groundCubes);
        function groundPlane(){
            let planeGeo = new THREE.BoxGeometry(10, 0.01, 10);
            let gp = new THREE.Mesh(planeGeo, groundCubesMat);
            groundCubes.push(gp);
            scene.add(gp);
        }
        function randCubes(heightDelta, sizeDelta, spacing, angleDelta, area) {
            let maxdim = spacing*1.5;
            let minDim = spacing;
            for(let x = 0; x < area; x+=spacing) {
                for(let z = 0; z<area; z+=spacing) {
                    let minx = Math.max(Math.random()*sizeDelta*maxdim, minDim);
                    let minz = Math.max(Math.random()*sizeDelta*maxdim, minDim);
                    //let boxGeo = new THREE.SphereGeometry(Math.random()*minDim*heightDelta, 16, 16); 
                    let boxGeo = new THREE.BoxGeometry(minx, Math.random()*minDim*heightDelta, minz);//new THREE.DodecahedronGeometry(minx, 1);//, Math.random()*minDim*heightDelta); //
                    let boxMesh = new THREE.Mesh(boxGeo, groundCubesMat);
                    boxMesh.position.x = x; boxMesh.position.z = z;
                    boxMesh.rotateX((angleDelta/2) - Math.random()*angleDelta);
                    boxMesh.rotateY((angleDelta/2) - Math.random()*angleDelta);
                    boxMesh.rotateZ((angleDelta/2) - Math.random()*angleDelta);
                    boxMesh.material.side = 0;
                    groundCubes.push(boxMesh);
                    
                    /*boxMesh.position.x = -area/2;
                    boxMesh.position.z = -area/2;*/
                    boxMesh.position.y = -1;
                    scene.add(boxMesh)
                }
            }
            /**groundCubes.position.x = -area/2;
            groundCubes.position.z = -area/2;
            groundCubes.position.y = -2;*/
        }
        
        
        function delayAnimate() {
            window.setTimeout(animate, window.frtime);
        }

        async function loadModel(position, loadId, onloaded) {
            let vrm = await loader.loadAsync(
                './vrmtests/testmodel.vrm',
                (xhr, otherParam) => { },
                (error) => { window.notifyStreamError(error, loadId) }
            );
            vrm.scene.updateMatrixWorld();
            scene.add(vrm.scene);
            scene.traverse((object) => {
                if (object.isSkinnedMesh) {
                  object.frustumCulled = false;
                }
              });
            let rootBone1 = vrm.scene.children[0];
            rootBone1.position.set(position.x, position.y, position.z);
            return onloaded(vrm, loadId);
        }
        const forwardVec = new Vec3(0,0,1);
        const leftVec = new Vec3(1,0,0);
        window.forwardVec = forwardVec; window.leftVec = leftVec;
        const tempVec = new Vec3(1,0,0);
        const temp3v = new THREE.Vector3(0,0,0);
        window.framecount = 0;
        window.physicsUpdateCount = 0;
        function animate() {
            requestAnimationFrame(delayAnimate);
            armature.c_hips.getWorldPosition(temp3v);
            tempVec.readFromTHREE(temp3v);
            //orbitControls.target.copy(boxxy.hips.position);
            forwardVec.readFromTHREE(orbitControls.target); 
            forwardVec.lerp(tempVec, 0.05);
            forwardVec.writeToTHREE(orbitControls.target);
            orbitControls.update();
            let updateCount = clock.getDelta()/window.frrate;
            tempVec.readFromTHREE(camera.position);
            forwardVec.readFromTHREE(orbitControls.target);
            forwardVec.sub(tempVec);
            forwardVec.y = 0;
            forwardVec.normalize();
            tempVec.setComponents(0,1,0);
            forwardVec.cross(tempVec, leftVec);
            leftVec.normalize();
            
            /*if(window.framecount % 60) {
                console.log(boxxy.hips.position.y.toFixed(5));
                //console.log(`physics updates: ${window.physicsUpdateCount} in ${window.framecount} frames`);
            }*/
            window.framecount++;
            if(window.dowalk) {
                for(let i=0; i<updateCount; i++) {
                    boxxy.update(forwardVec, leftVec, i==0);
                    window.physicsUpdateCount++;
                }
            }
            
            if(window.goahead) {
                window.armature.solve();
            }
            //console.log(acceleration);
            window.render();
        }
        
        init();
        window.camera = camera;

        window.render = function () {
            camera.layers.set(0);
            const currentBackground = scene.background;
            const currentFog = scene.fog;

            renderer.render(scene, camera);
            /*renderer.clearDepth();
            
            scene.background = null;
            scene.fog = null;
            camera.layers.set(1);
            renderer.render(scene, camera);
            scene.background = currentBackground;
            scene.fog = currentFog;*/

        }
        //animate();
                
    </script>
    <style>
        body {margin: 0;}
        canvas {display: block;}
    </style>
</body>
