<!DOCTYPE html>
<html>

<head>
    <title>GLTF Three.js Skeleton Interaction</title>
    <script type="importmap">
        {
          "imports": {
            "three": "https://unpkg.com/three@latest/build/three.module.js",
            "orbitControls": "https://unpkg.com/three/examples/jsm/controls/OrbitControls.js",
            "transformControls": "./js/penziltransform.js",
            "gltf" : "https://unpkg.com/three/examples/jsm/loaders/GLTFLoader.js",
            "vrm" : "https://unpkg.com/@pixiv/three-vrm@2.1.0/lib/three-vrm.module.js"
          }
        }
    </script>
    <style>
        body {
            margin: 0;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 8px;
            user-select: none;
            pointer-events: none;
        }
        #control-panel {
            z-index: 10; /* Ensure it's above other scene elements */
            background: rgba(255, 255, 255, 0.8); /* Semi-transparent white background */
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            position: absolute;
        }
        #control-panel button,
        #control-panel label {
            display: inline;
            margin-bottom: 5px;
        }        
    </style>
</head>
<body>
    <script type = "module" src="./js/UIelements.js"></script>
    <script src="js/sceneStuff.js"></script>
    <script type="module">
        const THREE = await import('three');
        import { LayeredRender } from "./js/LayeredRender.js"
        import { TransformControls } from 'transformControls';
        import { OrbitControls } from 'orbitControls';
        import { GLTFLoader } from 'gltf';
        //import { VRMLoaderPlugin } from 'vrm';
        import { EWBIK } from "./js/EWBIK/EWBIK.js";
        import { IKNode, TrackingNode } from "./js/EWBIK/util/IKNodes.js";
        import { Rot } from "./js/EWBIK/util/Rot.js";
        import { IKPin } from "./js/EWBIK/betterbones/IKpin.js";
        import { Rest } from "./js/EWBIK/betterbones/Constraints/Rest/Rest.js";
        window.Rest = Rest;
        window.OrbitControls = OrbitControls;
        window.TransformControls = TransformControls;
        window.IKNode = IKNode;
        window.TrackingNode = TrackingNode;
        window.IKPin = IKPin;
        window.meshLayer = 0;
        window.boneLayer = 1;
        window.widgetLayer = 2;
        //import { Rest } from "./js/EWBIK/betterbones/Constraints/Rest/Rest.js"

        let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(-0.61, 1.2, -1);
        let renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        window.camera = camera;
        window.renderer = renderer;
        window.rendlrs = new LayeredRender(renderer, window.innerWidth, window.innerHeight, 
            (renderer, target) => { //renders mesh stuff
                camera.layers.set(meshLayer);
                renderer.render(scene, camera);
            },
            (renderer, target) => { //renders bones
                camera.layers.set(boneLayer);
                renderer.render(scene, camera);
            },
            (renderer, target) => { //renders bones
                camera.layers.set(widgetLayer);
                renderer.render(scene, camera);
            }
        );      
        
        const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x0000, 3);
        const ambientLight = new THREE.AmbientLight(0x404040);
        hemisphereLight.layers.enable(boneLayer);
        ambientLight.layers.enable(boneLayer);

        let orbitControls, boneCtrls, pinOrientCtrls, pinTranslateCtrls;
        var scene = null;

        let selectedBone = null;
        let rootBone = null;

        const axesHelperSize = 24; // Adjust the size as needed
        window.boneAxesHelper = new THREE.AxesHelper(axesHelperSize);
        boneAxesHelper.layers.set(2);

       
        let armature = null;
        let frameCount = 0;
        window.instances = [];
        const loader = new GLTFLoader();
        window.autoSolve = false

        async function init() {
            // Scene
            scene = new THREE.Scene();
            scene.add(hemisphereLight);
            window.scene = scene;
            document.body.appendChild(renderer.domElement);
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            let inst1 = loadModel({ x: 0, y: 0, z: 0 });
            //let inst2 = loadModel({x: 0.5, y:0, z:0});
            window.addEventListener('resize', onWindowResize, false);
            initControls(THREE, renderer);

            //instances = await Promise.all([inst1, inst2]);
            render();
            let result = await ikify(await inst1);
            animate();
            //const helper = new THREE.SkeletonHelper(rootBone);
            //helper.material.linewidth = 5; // Make the helper lines thicker
            //scene.add(helper);/=
        }

        let lastIK = 0;
        async function ikify(inst) {
            window.fr=1;
            EWBIK.defaultWScale = 1;
            //let result = await orthonormalize(inst);
            return result;
            /*let armature = new EWBIK(inst.scene, true);
            rootBone = armature.rootBone;
            armature.armatureNode.forceOrthonormality = false;
            window.armatures.push(armature);
            armature.inferOrientations(armature.rootBone);
            printBoneNames(rootBone);
            initHumanoidRestConstraints(armature);
            initIK(armature);
            updateGlobalPinLists();
            updateGlobalBoneLists();
            addSceneArmature(armature);*/
            /*let armature2 = new EWBIK(instances[1].scene.children[0], false);
            armature2.armatureNode.forceOrthonormality = false;
            addSceneArmature(armature2);*/
        }

        async function loadModel(position) {
            let glb = await loader.loadAsync(
                //'vrmtests.lowpoly_rig/scene.gltf',
                './vrmtests/micha.glb',
                (xhr) => { console.log(`${(xhr.loaded / xhr.total * 100)}% loaded`); },
                (error) => { console.log('An error happened'); }
            );
            
            
            //glb.scene.scale.set(-1, -1, -1);
            /**
            
            
            
            
            glb.scene.scale.set(1, -1, -1); 
            glb.scene.scale.set(1, 1, 1);
            glb.scene.scale.set(1, 1, -1); 
            glb.scene.scale.set(1, -1, 1); 
            glb.scene.scale.set(-1, 1, 1); 
            glb.scene.scale.set(-1, 1, -1); 
            glb.scene.scale.set(-1, -1, 1);
            */
            
            
            
            scene.add(glb.scene);
            
            //let rootBone1 = glb.scene.children[0];
            //rootBone1.position.set(position.x, position.y, position.z);
            return glb;
            /*let armature1 = new EWBIK(rootBone1, false);
            armature1.armatureNode.forceOrthonormality = false;
            addSceneArmature(armature1);*/
    }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            render();
        }
        async function animate() {
            requestAnimationFrame(animate);
            render(true);
        }


        function initHumanoidRestConstraints(armature) {
            armature.head_pin = new IKPin(armature.bonetags["CC_Base_Head"]);
            armature.r_foot_pin = new IKPin(armature.bonetags["CC_Base_L_Foot"]);
            armature.r_hand_pin = new IKPin(armature.bonetags["CC_Base_R_Hand"]);
            armature.l_foot_pin = new IKPin(armature.bonetags["CC_Base_R_Foot"]);
            armature.l_hand_pin = new IKPin(armature.bonetags["CC_Base_L_Hand"]);
            armature.head_pin.setPinWeight(2);

            for (let b of armature.bones) {
                if (b.parent instanceof THREE.Bone)
                    new Rest(b);
            }

        }

        window.render = function (incrFrame = false) {
            if (incrFrame) frameCount++;
            //setPinVisibility(frameCount%2 == 0);
            window.fr++;
            window.rendlrs.render();
        }

        /*window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children);
            if (intersects.length > 0 && intersectsDisplay != null) {
                let intersect = intersects[0]; // Closest intersected object
                for(let inx of intersects) {
                    if(inx?.object?.visible) {
                        intersect = inx;
                        break;
                    }
                    console.log('what');
                }
                intersectsDisplay.innerText = `
                Intersected Coordinates: ${intersect.point.x.toFixed(2)}, ${intersect.point.y.toFixed(2)}, ${intersect.point.z.toFixed(2)} 
                ${intersect?.object?.type ?? ''} : ${intersect?.object?.name ?? intersect?.object?.ikd }`;
                //console.log(intersects);
            }
        })*/

        init();
        //animate();
    </script>
</body>

</html>