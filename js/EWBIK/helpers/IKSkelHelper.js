import * as THREE from 'three';
import { convexBlob, pcaOrientation } from "../util/mathdump/mathdump.js";
import { IKPin } from "../EWBIK.js";
import { Rest, Twist, Kusudama, LimitCone, ConstraintStack} from "../betterbones/Constraints/ConstraintStack.js";
import { Bone } from "three";
import { EWBIK } from "../EWBIK.js";
import { ConstraintHelper } from "./constraintHelpers/ConstraintHelper.js";
import { IKPinHelper } from "./IKPinHelper.js"
import { KusudamaHelper } from "./constraintHelpers/Kusudamas/KusudamaHelper.js";
import { TwistHelper  } from "./constraintHelpers/TwistHelper/TwistHelper.js";
import { StackHelper } from './constraintHelpers/StackHelper/ConstraintStackHelper.js';
import { RestHelper } from './constraintHelpers/RestHelper/RestHelper.js';


export class IKSkelHelper {

    armature;
    boneMeshList = []; //contains the meshes autogenerated by showBones
    targMeshList = []; //ikpin meshes
    constraintHelpers = new Map();
    pinHelpers = new Map();
    pinVizType = 'BoneGeo';
    
    ikBoneLayer = 0;
    irrelevantBoneLayer = 0;
    constraintLayer = -1;
    pinLayer = -1;
    boneGeoRadius = 0.1;
    boneGeoMode = 'plate';
    minBoneGeoHeight = 0.001;
    updateCallback = (helpers)=>{};

    /**
     * 
     * @param {EWBIK} armature the EWBIK armature this helper visualize.
     * @param {Number} boneGeoRadius the minimum radius to use for the bone. This will be scaled by the bone's height for arbitrary aesthetic reasons.
    * @param {String} boneGeoMode one of 'cone' or 'plate'. The former will just draw a cone of the provided radius with the height of each bone. The latter will infer geometry for the bone by the convex hull of a conve and the bases of the bone and its child bones
    * @param {Number} minBoneGeoHeight the minimum height to give the bone cone (so that  it's still visible if the bone height itself is too small)
    * @param {Function} updateCallback an optional callback to fire after any updates this helper makes to the scene hierarchy (if you want to, e.g, keep your UI stuff up to date.)
     */
    constructor(armature, 
        boneGeoRadius = this.boneGeoRadius,
        boneGeoMode = this.boneGeoMode,
        minBoneGeoHeight = this.minBoneGeoHeight,
        updateCallback = this.updateCallback) {
        this.boneGeoRadius = boneGeoRadius; 
        this.boneGeoMode = boneGeoMode;
        this.minBoneGeoHeight = minBoneGeoHeight; 
        this.armature = armature; 
        this.armature.helper = this;       
        this.armature.registerPostSolveCallback(this.postSolveListener);        
    }

    /**
     * generates the displays for helpers on this armature.
     * the special and default value -1 for pins and constraints will be interpreted to mean that the item should be displayed on whatever layer the bone it's for is displayed
     * 
     * @param {Number} ikBoneLayer the layer to display solver-relevant bone geometry on. Set to -2 if you don't wish to generate solver relevant bone geometry at all. default 0.
     * @param {Number} irrelevantBoneLayer  the layer to display solver-irrelevant bone geometry on. Set to -2 if you don't wish to generate solver irrelevant bone geometry at all. default 0.
     * @param {Number} constraintLayer the layer to display constraint helpers on, set to -2 if you don't wish to generate constraint helpers at all. default -1.
     * @param {Number} pinLayer the layer to display IKPin helpers on. set to -2 if you don't wish to generate IKPin helpers at all. default -1.
     */
    init(ikBoneLayer = 0, irrelevantBoneLayer = 0, constraintLayer = -1, pinLayer = -1) {
        this.ikBoneLayer = ikBoneLayer;
        this.irrelevantBoneLayer = irrelevantBoneLayer;
        this.constraintLayer = constraintLayer;
        this.pinLayer = pinLayer;
        this.refreshSubHelpers();
    }
    
    /**
     * sets the layers on which the helpers will be displayed without otherwise updating or modifying the subhelpers.
     * 
     * providing null for any of the values below will set their set their visibility to false. default for all inputs is whatever they were the previous call to this function,
     * the special and default value -1 for pins and constraints will be interpreted to mean that the item should be displayed on whatever layer the bone it's for is displayed.
     * 
     * @param {Number} ikBoneLayer the layer to display solver-relevant bone geometry on. Set to -2 if you don't wish to generate solver relevant bone geometry at all. default 0.
     * @param {Number} irrelevantBoneLayer  the layer to display solver-irrelevant bone geometry on. Set to -2 if you don't wish to generate solver irrelevant bone geometry at all. default 0.
     * @param {Number} constraintLayer the layer to display constraint helpers on, set to -2 if you don't wish to generate constraint helpers at all. default -1.
     * @param {Number} pinLayer the layer to display IKPin helpers on. set to -2 if you don't wish to generate IKPin helpers at all. default -1.
     */
    setDisplayLayers(ikBoneLayer = this.ikBoneLayer, irrelevantBoneLayer = this.irrelevantBoneLayer, constraintLayer = this.constraintLayer, pinLayer = this.pinLayer) {
        this.ikBoneLayer = ikBoneLayer;
        this.irrelevantBoneLayer = irrelevantBoneLayer;
        this.constraintLayer = constraintLayer;
        this.pinLayer = pinLayer;
        this.updateBoneRelevanceMats();
    }


    /**a callback which is used to determine if IKPins should be visible */
    pinVisibilityCondition(forPin, forBone) {
        return true;
    }

    __pinVisibilityCondition(forPin, forBone) {
        return this.pinVisibilityCondition(forPin, forBone);
    }
    
    /**a callback which is used to determine if constraints should be visible */
    constraintVisibilityCondition(forConstraint, forBone) {
        return true;
    }

    __constraintVisibilityCondition(forConstraint, forBone) {
        return this.constraintVisibilityCondition(forConstraint, forBone);
    }
   


    async postSolveListener(wb) {
        if(wb.forBone.bonegeo == null) return;
        let pain = wb.getOwnPain();
        let bonecol = wb.forBone.bonegeo.material.color;
        wb.forBone?.getConstraint()?.helper?.updateDisplay();
        bonecol.r = pain;
        bonecol.g = 1 - pain;
        bonecol.b = 0.2;
    }
    
    /**
     * call to ensure that this helper is correctly displaying the helpers for any new constraints, bone's, pins etc that may have been added to or removed from the armature after this helper was initialized (or after the last time this function was called).
    *
    * @param {Number} boneGeoRadius the minimum radius to use for the bone. This will be scaled by the bone's height for arbitrary aesthetic reasons.
    * @param {String} boneGeoMode one of 'cone' or 'plate'. The former will just draw a cone of the provided radius with the height of each bone. The latter will infer geometry for the bone by the convex hull of a conve and the bases of the bone and its child bones
    * @param {Number} minBoneGeoHeight the minimum height to give the bone cone (so that  it's still visible if the bone height itself is too small) 
    */
    refreshSubHelpers(boneGeoRadius = this.boneGeoRadius,
        boneGeoMode = this.boneGeoMode,
        minBoneGeoHeight = this.minBoneGeoHeight) {
        this.boneGeoRadius = boneGeoRadius; 
        this.boneGeoMode = boneGeoMode;
        this.minBoneGeoHeight = minBoneGeoHeight;
        this.maybeRegenIKBones(true);
        this.maybeRegenIrrelevantBones(true);
        this.maybeRegenConstraintHelpers(true);
        this.maybeRegenIKPins(true);
        this.updateBoneRelevanceMats();
        this.setDisplayLayers();
        this.updateCallback([this]);
    }

    updateBoneRelevanceMats() {
        if(this.armature?.shadowSkel != null) {
            for(let b of this.armature.bones) {
                if(b.bonegeo == null) continue;
                let layerChosen = this.ikBoneLayer;
                b.bonegeo.layers.disableAll();
                if(this.armature.shadowSkel.isSolvable(b)) {
                    b.bonegeo.material = b.bonegeo.ikBoneMat ?? this.ikBoneMat.clone();
                    b.bonegeo.layers.set(this.ikBoneLayer);
                } else {
                    b.bonegeo.material = this.irrelevantBoneMat;
                    b.bonegeo.layers.set(this.irrelevantBoneLayer);
                    layerChosen = this.irrelevantBoneLayer;
                }
                let p = b.getIKPin();
                let c = b.getConstraint();
                if(p != null && this.pinHelpers.has(p)) {
                    let ph = this.pinHelpers.get(p);
                    ph.layers.disableAll();
                    if(this.pinLayer != -2)
                        ph.layers.set(this.pinLayer == -1 ? layerChosen : this.pinLayer);
                }
                if(c != null && this.constraintHelpers.has(c)) {
                    let ch = this.constraintHelpers.get(c);
                    let schs = [ch];
                    if(c instanceof ConstraintStack) {
                        for(let sc of c.getAllConstraints()) {
                            let sch = this.constraintHelpers.get(sc);
                            if(sch != null)
                                schs.push(sch);
                        }
                    } 
                    for(let sch of schs) {
                        sch.layers.disableAll();
                        if(this.constraintLayer != -2) {
                            sch.layers.set(this.constraintLayer == -1 ? layerChosen : this.constraintLayer);
                        }    
                    }                    
                }
            }
        }
    }

    /**creates or supplements visualizers for any solver relevant bones on the skeleton*/
    maybeRegenIKBones(skipPostUpdate = false) {
        if(this.ikBoneLayer > -1) {
            if (this.dirtyShadowSkel) this.regenerateShadowSkeleton();
            for (const bone of this.armature.bones) {
                if(this.armature?.shadowSkel?.isSolvable(bone) ) {
                    this.makeBoneMesh(bone, 0.1, this.boneGeoMode, 0.0001);
                    bone.bonegeo.material = bone.bonegeo.ikBoneMat?? this.ikBoneMat.clone();                 
                }
            }
        }
        if(!skipPostUpdate) {
            this.updateBoneRelevanceMats(); 
            this.updateCallback();
        }
    }

    /**creates or supplements visualizers for any IKPins on the skeleton*/
    maybeRegenIrrelevantBones(skipPostUpdate = false) {
        if(this.irrelevantBoneLayer > -1) {
            if (this.dirtyShadowSkel) this.regenerateShadowSkeleton();
            for (const bone of this.armature.bones) {
                if(!this.armature?.shadowSkel?.isSolvable(bone) ) {
                    this.makeBoneMesh(bone, 0.1, this.boneGeoMode, 0.0001);
                    bone.bonegeo.material = this.irrelevantBoneMat;
                }
            }
        }
        if(!skipPostUpdate) {
            this.updateBoneRelevanceMats(); 
            this.updateCallback();
        }
    }
    maybeRegenConstraintHelpers(skipPostUpdate = false) {
        if(this.constraintLayer > -2) {
            for (const b of this.armature.bones) { 
                let onLayer = this.constraintLayer;
                if(this.constraintLayer == -1) {
                    if(this.armature?.shadowSkel?.isSolvable(b)) {
                        onLayer = this.ikBoneLayer;
                    } else {
                        onLayer = this.irrelevantBoneLayer;
                    }
                }
                let c = b.getConstraint();
                let ca = [c];
                if(c != null && c instanceof ConstraintStack) {
                    ca.push(...c.getAllConstraints());
                }
                for(let sc of ca) {
                    let ch = this.constraintHelpers.get(sc);
                    if(ch == null) {
                        if(sc instanceof ConstraintStack) {
                            ch = new StackHelper(sc, this.constraintVisibilityCondition);
                        } else if(sc instanceof Kusudama) {
                            ch = new KusudamaHelper(sc, this.constraintVisibilityCondition);
                        } else if (sc instanceof Twist) {   
                            ch = new TwistHelper(sc,this.constraintVisibilityCondition);
                        } else if (sc instanceof Rest) {
                            ch = new RestHelper(sc, this.constraintVisibilityCondition);
                        }
                        if(ch != null)
                            this.constraintHelpers.set(sc, ch);
                    }
                }
                if(c != null) {
                    this.constraintHelpers.get(c).regenDisplay(c);
                    this.constraintHelpers.get(c).updateDisplay(c);
                }
            }
        }
        if(!skipPostUpdate) {
            this.updateBoneRelevanceMats(); 
            this.updateCallback();
        }
    }
    maybeRegenIKPins(skipPostUpdate = false) {
        if(this.pinLayer > -2) {
            for (const b of this.armature.bones) { 
                let onLayer = this.pinLayer;
                if(this.pinLayer == -1) {
                    if(this.armature?.shadowSkel?.isSolvable(b)) {
                        onLayer = this.ikBoneLayer;
                    } else {
                        onLayer = this.irrelevantBoneLayer;
                    }
                }
                let p = b.getIKPin();
                let helper = this.pinHelpers.get(p);
                if(p != null) {
                    if( helper == null) {
                        helper = new IKPinHelper(p, this.pinVizType, this.pinVisibilityCondition);
                        this.pinHelpers.set(p, helper);
                    }
                    helper.layers.set(onLayer);
                    if(this.targMeshList.indexOf(helper.orientTargMesh) == -1) {
                        this.targMeshList.push(helper.orientTargMesh);
                    }
                    if(this.targMeshList.indexOf(helper.posOnlyMesh) == -1) {
                        this.targMeshList.push(helper.posOnlyMesh);
                    }
                }
            }
        }
        if(!skipPostUpdate) {
            this.updateBoneRelevanceMats(); 
            this.updateCallback();
        }
    }

    makeBoneGeo(boneRef, minHeight, radius, mat, hullpoints) {
        const height = boneRef.__height_is_placeholder ? boneRef.getInferredHeight('statistical', minHeight) : boneRef.height; 
        let wScale = boneRef.scale.clone();
        boneRef.getWorldScale(wScale);
        const cone = new THREE.ConeGeometry(radius * height, height / wScale.y, 5);
        cone.translate(0, (height / wScale.y) / 2, 0);
        const hull = hullpoints.length > 1 ? convexBlob(cone, ...hullpoints) : cone;
        const material = mat;
        const boneplate = new THREE.Mesh(hull, material);
        boneplate.ikBoneMat = this.ikBoneMat.clone();
        //boneplate.position.y = height / 2;
        boneplate.isBoneMesh = true;
        boneplate.forBone = boneRef;
        boneplate.name = 'bonegeo';
        boneplate.visible = true;
        return boneplate;
    }  

    /**
     * creates and adds to the scene physical manifestations of each bone on this armature,
     * @param radius width of bones
     * @param solvedOnly if false, will render all bones, not just the solver relevant ones.
     * @param mode 'cone' or 'plate'. With the latter displahying the convex hull of the union of a cone and the bases of the children
     * @param minHeight the minimum height in global space
     */
    generateBoneMeshes(radius = 0.5, solvedOnly = false, mode = 'plate', minHeight=0.001) {
        this.boneMeshList.slice(0, 0);
        this.boneGeoMode = mode;
        if (this.dirtyShadowSkel) this.regenerateShadowSkeleton();
        for (const bone of this.bones) {
            this.makeBoneMesh(bone, radius, this.boneGeoMode, minHeight);
        }
    }

    irrelevantBoneMat = new THREE.MeshPhongMaterial({ color: new THREE.Color(0.3, 0.3, 0.3), transparent: true, opacity: 0.6 });
    ikBoneMat = new THREE.MeshPhongMaterial({ color: new THREE.Color(0.2, 0.2, 0.8), transparent: true, opacity: 0.6 });

    /**creates or recreates mesh and geometry to display the given bone*/
    makeBoneMesh(bone, radius, mode = 'cone', minHeight = 0.001) {
        let oldGeo = bone.bonegeo;
        let idx = this.boneMeshList.indexOf(oldGeo);
        let orientation = bone.getIKBoneOrientation();
        let matObj = this.irrelevantBoneMat;
        let hullPoints = [];
        if(mode =='plate') {                
            for (let c of bone.childBones()) {
                c.updateWorldMatrix();
                hullPoints.push(orientation.worldToLocal(bone.localToWorld(c.position.clone())));
            }
        }
        let wradius = radius/bone.getWorldScale(bone.scale.clone()).z;
        let thisRadius = bone.parent instanceof THREE.Bone ? wradius : wradius / 2; //sick and tired of giant root bones. Friggen whole ass trunks.
        let bonegeo = this.makeBoneGeo(bone, minHeight, thisRadius, matObj, hullPoints);
        orientation.bonegeo = bonegeo;
        this.setBonegeo(bone, bonegeo);
        bone.bonegeo.displayradius = thisRadius; 
        bone.visible = true;

        if(idx != -1) {
            this.boneMeshList[idx] = bone.bonegeo;
        } else {
            this.boneMeshList.push(bone.bonegeo);
        }
        if(bone?.parentArmature?.shadowSkel?.isSolvable(bone)) {
            bone.bonegeo.layers.set(this.ikBoneLayer);
            bone.bonegeo.material = bone.bonegeo.ikBoneMat ?? this.ikBoneMat.clone();
        } else {
            bone.bonegeo.layers.set(this.irrelevantBoneLayer);
            bone.bonegeo.material = this.irrelevantBoneMat;
        }
        
        
        return bonegeo;
    }

    printInitializationString(doPrint=true) {
        let string = ``;
        let p = this.forPin;
        //let boneName = p.forBone.name;
        let res = '';
        let printed = new Set();
        for(let [sc_, sc] of this.constraintHelpers) {
            if(!(sc instanceof StackHelper)) {
                printed.add(sc);
                res += '\n' + sc?.printInitializationString(false);
            }
        }

        res+='\n\n';
        let respins = '';
        for(let [p, ph] of this.pinHelpers) {
            respins+='\n' + p.printInitializationString(false);
        }
        
        console.log(res + respins);
    }

    setBonegeo(bone, newgeo) {
        if (newgeo != null) {
            if (bone.bonegeo != newgeo) {
                bone.orientation.remove(bone.bonegeo);
                bone.bonegeo?.geometry.dispose();
            }
            if (bone.orientation.children.indexOf(newgeo) == -1)
                bone.orientation.add(newgeo);
        }
        bone.orientation.bonegeo = newgeo;
        bone.bonegeo = newgeo;
        bone.bonegeo.geometry.computeBoundingBox();
        bone.bonegeo.geometry.computeBoundingSphere();
    }


    _visible = true;
    get visible() {
        return this._visible;
    }

    /**
     * determines whether or not to display any bone mesh or constraint hints from this EWBIK manager
     * @param {Boolean} val
     */
    set visible(val) {
        if(val != this._visible) {
            if(!val) {
                this.armature.removePostSolveCallback(this.postSolveListener);
            } else {
                this.armature.registerPostSolveCallback(this.postSolveListener);
            }
        }
        this._visible = val; 
        for(let b of this.armature.bones) {
            if(b.bonegeo != null) {
                b.bonegeo.visible = this._visible;
            }
        }
    }   
}

export {
    IKPinHelper,
    ConstraintHelper,
    TwistHelper,
    KusudamaHelper,
    RestHelper
}