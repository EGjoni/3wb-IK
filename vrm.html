<!DOCTYPE html>
<html>

<head>
    <title>Three.js Skeleton Interaction</title>
    <script> global = window;</script>
    <script type="importmap">
        {
          "imports": {
            "three": "./js/three/three.module.js",
            "orbitControls": "./js/three/jsm/OrbitControls.js",
            "transformControls": "./js/penziltransform.js",
            "gltf" : "./js/three/jsm/GLTFLoader.js",
            "vrm" : "./js/three/jsm/three-vrm.module.js",
            "convexGeo": "./js/EWBIK/util/mathdump/ConvexHull.js",
            "enviro" : "./js/environment.js"
          }
        }
    </script>

</head>


<body>
    <script type="module" src="./js/UIelements.js"></script>
    <script src="js/sceneStuff.js"></script>
    <script type="module">
        import *  as THREE from "three";
        import { LayeredRender } from "./js/LayeredRender.js"
        import { TransformControls } from 'transformControls';
        import { OrbitControls } from 'orbitControls';
        import { GLTFLoader } from 'gltf';
        import { VRMLoaderPlugin } from 'vrm';
        import { EWBIK } from "./js/EWBIK/EWBIK.js";
        import { IKNode, TrackingNode } from "./js/EWBIK/util/nodes/IKNodes.js";
        import { IKPin } from "./js/EWBIK/betterbones/IKpin.js";
        import { Rest, Twist, Kusudama } from "./js/EWBIK/betterbones/Constraints/ConstraintStack.js";
        import { getMeshDescendants, initEnvironment } from "enviro";
        addDebugFuncs(THREE);
        window.Rest = Rest;
        window.OrbitControls = OrbitControls;
        window.TransformControls = TransformControls;
        window.IKNode = IKNode;
        window.TrackingNode = TrackingNode;
        window.IKPin = IKPin;
        window.autoSolve = false;

        window.meshLayer = 0;
        window.boneLayer = 1;

        let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(-0.61, 1.2, -1);
        window.renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setClearColor(0x000000, 0);
        renderer.setSize(window.innerWidth, window.innerHeight);
        window.camera = camera;
        window.renderer = renderer;
        /*window.rendlrs = new LayeredRender(renderer, window.innerWidth, window.innerHeight, 
            (renderer, target) => { //renders mesh stuff
                camera.layers.set(meshLayer);
                renderer.render(scene, camera);
            },
            (renderer, target) => { //renders bones
                camera.layers.set(boneLayer);
                renderer.render(scene, camera);
            }
        );*/

        //const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x000000, 0.5);
        //const ambientLight = new THREE.AmbientLight(0x404040);
        //hemisphereLight.layers.enable(boneLayer);
        //ambientLight.layers.enable(boneLayer);

        let orbitControls, boneCtrls, pinOrientCtrls, pinTranslateCtrls;
        var scene = null;

        let selectedBone = null;
        let rootBone = null;
        let armature = null;
        window.frameCount = 0;
        window.instances = [];
        window.debugLog = []
        window.log = function (elem, identifier = null) {
            if (elem.clone !== null) {
                let state = elem.clone();
                state.__of = identifier;
                debugLog.push(state);
            } else {
                debugLog.push(elem);
            }
        }

        const loader = new GLTFLoader();

        async function init() {
            scene = new THREE.Scene();
            //scene.add(hemisphereLight);
            window.scene = scene;
            document.body.appendChild(renderer.domElement);
            //scene.add(ambientLight);

            loader.register((parser) => {
                return new VRMLoaderPlugin(parser);
            });

            window.addEventListener('resize', onWindowResize, false);
            //autoSolve = false;
            interactionSolve = false;
            initControls(THREE, renderer);

            let inst1 = await loadModel({ x: 0, y: 0, z: 0 }, 0, ikify);
            window.nek1 = inst1;
            armature = inst1;
            //let inst2 = await loadModel({x: 0.5, y:0, z:0}, 1, ikify);
            //window.nek2= inst2



            armature.dirtyRate = true;
            initEnvironment(scene, renderer, //scene,
                [...getMeshDescendants(nek1.armatureObj3d.children[1]),
                ...getMeshDescendants(nek1.armatureObj3d.children[2])],
                [0, 1]
            );


            //instances = await Promise.all([inst1, inst2]);
            //armature.solve();
            render();
        }

        let lastIK = 0;
        function ikify(inst, loadId) {
            window.updateParseStream("Building IK Armature...", loadId);
            let armature = new EWBIK(inst.scene.children[0]);
            armature.setDefaultIterations(7);
            armature.setDampening(1);
            armature.armatureNode.forceOrthonormality = false;
            window.armatures.push(armature);

            window.updateParseStream("Inferring Bone directions and appearance...", loadId);
            initPrettyBones(armature);
            window.updateParseStream("Addings constraints...", loadId);
            initHumanoidRestConstraints(armature);
            makePinsList(1, armature.armatureObj3d, armature, true);
            window.updateParseStream("UI stuff...", loadId);
            updateGlobalBoneLists();
            initIK(armature);
            window.updateParseStream(null, loadId);
            return armature;
        }

        async function loadModel(position, loadId, onloaded) {

            let vrm = await loader.loadAsync(
                './vrmtests/testmodel.vrm',
                (xhr, otherParam) => { window.updateLoadStream(xhr, loadId) },
                (error) => { window.notifyStreamError(error, loadId) }
            );
            scene.add(vrm.scene);
            let rootBone1 = vrm.scene.children[0];
            rootBone1.position.set(position.x, position.y, position.z);
            window.updateParseStream("Scene instaniated...", loadId);
            return onloaded(vrm, loadId);
            /*let armature1 = new EWBIK(rootBone1);
            armature1.armatureNode.forceOrthonormality = false;
            addSceneArmature(armature1);*/
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            render();
        }

        async function animate() {
            window.frameCount++;
            requestAnimationFrame(animate);
            doSolve();
            render();
        }

        window.render = function () {


            camera.layers.set(0);
            window.renderer.render(scene, camera);
            window.renderer.clearDepth();
            const currentBackground = scene.background;
            const currentFog = scene.fog;
            scene.background = null;
            scene.fog = null;
            camera.layers.set(1);
            window.renderer.render(scene, camera);
            scene.background = currentBackground;
            scene.fog = currentFog;

        }

        function initHumanoidRestConstraints(armature) {

            armature.l_arm_upp = armature.bonetags["J_Bip_L_UpperArm"];
            armature.r_arm_upp = armature.bonetags["J_Bip_R_UpperArm"];
            armature.l_arm_lower = armature.bonetags["J_Bip_L_LowerArm"];
            armature.r_arm_lower = armature.bonetags["J_Bip_R_LowerArm"];
            armature.l_leg_upp = armature.bonetags["J_Bip_L_UpperLeg"];
            armature.r_leg_upp = armature.bonetags["J_Bip_R_UpperLeg"];
            armature.l_leg_lower = armature.bonetags["J_Bip_L_LowerLeg"];
            armature.r_leg_lower = armature.bonetags["J_Bip_R_LowerLeg"];
            armature.c_head = armature.bonetags["J_Bip_C_Head"];
            armature.c_hips = armature.bonetags["J_Bip_C_Hips"];
            armature.c_chest = armature.bonetags["J_Bip_C_Chest"];
            armature.r_foot = armature.bonetags["J_Bip_R_Foot"];
            armature.l_foot = armature.bonetags["J_Bip_L_Foot"];
            armature.upper_chest = armature.bonetags["J_Bip_C_UpperChest"];

            //override the autoinferred orientation for the legs because this rig has weird tassles that throw it off
            armature.setInternalOrientationFor(armature.r_leg_lower, armature.r_foot.position);
            armature.setInternalOrientationFor(armature.l_leg_lower, armature.l_foot.position);

            //snip the root bone (make it shorter).
            armature.c_hips.parent.position.y = armature.c_hips.position.y -0.01;
            armature.c_hips.position.y = 0.01;
            armature.makeBoneMesh(armature.c_hips.parent, armature.c_hips.parent.boneRadius);

            new Kusudama(armature.bonetags["J_Bip_L_UpperLeg"], (cnstrt, bone) => bone == contextBone, "Kusudama for J_Bip_L_UpperLeg", armature.stablePool)
            .addLimitConeAtIndex(0, armature.stablePool.any_Vec3(-0.2505336783387944, -0.2645716928861982, -0.9312543666159987), 0.48411).parentKusudama
            .addLimitConeAtIndex(1, armature.stablePool.any_Vec3(-0.3143631992559614, -0.7667395103803937, -0.5597198425776874), 0.69579).parentKusudama
            .addLimitConeAtIndex(2, armature.stablePool.any_Vec3(0, -0.9578262852211515, 0.28734788556634544), 0.45589);
            new Twist(armature.bonetags["J_Bip_L_UpperLeg"], 0.70009, undefined, 
                armature.stablePool.any_Vec3(1.9041464198590058e-8, -0.9996624984362763, 0.025978630066681115), 
                0, (cnstrt, bone) => bone == contextBone,
                "Twist for J_Bip_L_UpperLeg", armature.stablePool);


            new Kusudama(armature.bonetags["J_Bip_L_LowerLeg"], (t, b) => b==contextBone, "Kusudama for J_Bip_L_LowerLeg", armature.stablePool)
                .addLimitConeAtIndex(0, armature.stablePool.any_Vec3(0, -0.8984406832782645, 0.055822952043333464), 0.1).parentKusudama
                .addLimitConeAtIndex(1, armature.stablePool.any_Vec3(0, 0.7518876717414535, 0.6592912323724746), 0.1);
            new Twist(armature.bonetags["J_Bip_L_LowerLeg"], 0.34729, undefined, 
                            armature.stablePool.any_Vec3(0, -0.9987182064357158, 0.050615651075934326), 
                            0, (cnstrt, bone) => bone == contextBone,
                            "Twist for J_Bip_L_LowerLeg", armature.stablePool);

            new Kusudama(armature.bonetags["J_Bip_L_Foot"], (t, b) => b==contextBone, "Kusudama for J_Bip_L_Foot", armature.stablePool)
            .addLimitConeAtIndex(0, armature.stablePool.any_Vec3(0, -0.5256465905493974, -0.8507030397522946), 0.75224);
            new Twist(armature.bonetags["J_Bip_L_Foot"], 1.78672, undefined, 
                            armature.stablePool.any_Vec3(0, -0.5256465905493974, -0.8507030397522946), 
                            6.19399, (cnstrt, bone) => bone == contextBone,
                            "Twist for J_Bip_L_Foot", armature.stablePool);

            new Kusudama(armature.bonetags["J_Bip_R_UpperLeg"], (cnstrt, bone) => bone == contextBone, "Kusudama for J_Bip_R_UpperLeg", armature.stablePool)
            .addLimitConeAtIndex(0, armature.stablePool.any_Vec3(0.2505336783387944, -0.2645716928861982, -0.9312543666159987), 0.48411).parentKusudama
            .addLimitConeAtIndex(1, armature.stablePool.any_Vec3(0.3143631992559614, -0.7667395103803937, -0.5597198425776874), 0.69579).parentKusudama
            .addLimitConeAtIndex(2, armature.stablePool.any_Vec3(0, -0.9578262852211515, 0.28734788556634544), 0.45589);
            new Twist(armature.bonetags["J_Bip_R_UpperLeg"], 0.70009, undefined, 
                armature.stablePool.any_Vec3(-1.9041464198590058e-8, -0.9996624984362763, 0.025978630066681115), 
                0, (cnstrt, bone) => bone == contextBone,
                "Twist for J_Bip_R_UpperLeg", armature.stablePool);


            new Kusudama(armature.bonetags["J_Bip_R_LowerLeg"], (t, b) => b==contextBone, "Kusudama for J_Bip_R_LowerLeg", armature.stablePool)
                .addLimitConeAtIndex(0, armature.stablePool.any_Vec3(0, -0.8984406832782645, 0.055822952043333464), 0.1).parentKusudama
                .addLimitConeAtIndex(1, armature.stablePool.any_Vec3(0, 0.7518876717414535, 0.6592912323724746), 0.1);
            new Twist(armature.bonetags["J_Bip_R_LowerLeg"], 0.34729, undefined, 
                            armature.stablePool.any_Vec3(0, -0.9987182064357158, 0.050615651075934326), 
                            0, (cnstrt, bone) => bone == contextBone,
                            "Twist for J_Bip_R_LowerLeg", armature.stablePool);

            new Kusudama(armature.bonetags["J_Bip_R_Foot"], (t, b) => b==contextBone, "Kusudama for J_Bip_R_Foot", armature.stablePool)
            .addLimitConeAtIndex(0, armature.stablePool.any_Vec3(0, -0.5256465905493974, -0.8507030397522946), 0.75224);
            new Twist(armature.bonetags["J_Bip_R_Foot"], 1.78672, undefined, 
                            armature.stablePool.any_Vec3(0, -0.5256465905493974, -0.8507030397522946), 
                            6.19399, (cnstrt, bone) => bone == contextBone,
                            "Twist for J_Bip_R_Foot", armature.stablePool);


            armature.l_arm_upp.rotateZ(0.5);
            armature.r_arm_upp.rotateZ(-0.5);

            armature.l_arm_lower.rotateX(0.5);
            armature.r_arm_lower.rotateX(0.5);

            armature.l_arm_lower.rotateY(-0.75);
            armature.r_arm_lower.rotateY(0.75);

            armature.r_leg_upp.rotateY(-.5);
            armature.l_leg_upp.rotateY(.5);

            armature.r_leg_upp.rotateX(1);
            armature.l_leg_upp.rotateX(1);

            armature.r_leg_lower.rotateX(-1.75);
            armature.l_leg_lower.rotateX(-1.75);

            for (let b of armature.bones) {
                if (b.getConstraint() == null) {
                    let restconst = new Rest(b);
                    if (b == armature.bonetags["J_Bip_C_Head"]) {
                        restconst.setPainfulness(0.7);
                        restconst.setStockholmRate(0.8);
                    }
                    if (b == armature.bonetags["J_Bip_C_Neck"]) {
                        restconst.setPainfulness(0.5);
                        restconst.setStockholmRate(0.8);
                    }
                    if (b == armature.bonetags['J_Bip_L_Shoulder']) {
                        restconst.setPainfulness(0.8);
                        restconst.setStockholmRate(0.8);
                    }

                    if (b == armature.bonetags['J_Bip_R_Shoulder']) {
                        restconst.setPainfulness(0.8);
                        restconst.setStockholmRate(0.8);
                    }
                }
            }

            armature.r_leg_lower.rotateX(1.75);
            armature.l_leg_lower.rotateX(1.75);

            armature.r_leg_upp.rotateX(-1);
            armature.l_leg_upp.rotateX(-1);

            armature.r_leg_upp.rotateY(.5);
            armature.l_leg_upp.rotateY(-.5);

            armature.l_arm_lower.rotateY(0.75);
            armature.r_arm_lower.rotateY(-0.75);

            armature.l_arm_lower.rotateX(-0.5);
            armature.r_arm_lower.rotateX(-0.5);

            armature.l_arm_upp.rotateZ(-0.5);
            armature.r_arm_upp.rotateZ(0.5);

            /*for (let b of armature.bones) {
                if (b.parent instanceof THREE.Bone) {
                    let twistConst = new Twist(b, 1.1).setVisibilityCondition((twist, bone) => { return bone == window.contextBone });
                    twistConst.layers.set(window.boneLayer);
                }
            }*/

            //armature.root = new IKPin(armature.bonetags["Root"]);
            //armature.hips = new IKPin(armature.bonetags["J_Bip_C_Hips"]);
            armature.head_pin = new IKPin(armature.c_head);
            //armature.c_uuperchest_pin = new IKPin(armature.upper_chest);
            armature.r_hand_pin = new IKPin(armature.bonetags["J_Bip_R_Hand"]);
            armature.l_hand_pin = new IKPin(armature.bonetags["J_Bip_L_Hand"]);
            armature.r_foot_pin = new IKPin(armature.bonetags["J_Bip_R_Foot"]);
            armature.l_foot_pin = new IKPin(armature.bonetags["J_Bip_L_Foot"]);
        }

        init();
        animate();
    </script>
</body>

</html>