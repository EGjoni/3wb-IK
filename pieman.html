<!DOCTYPE html>
<html>

<head>
    <title>Three.js Skeleton Interaction</title>
    <script> global = window;</script>
    <script type="importmap">
        {
          "imports": {
            "three": "./js/three/three.module.js",
            "orbitControls": "./js/three/jsm/OrbitControls.js",
            "transformControls": "./js/penziltransform.js",
            "gltf" : "./js/three/jsm/GLTFLoader.js",
            "vrm" : "./js/three/jsm/three-vrm.module.js",
            "convexGeo": "./js/EWBIK/util/mathdump/ConvexHull.js",
            "enviro" : "./js/environment.js"
          }
        }
    </script>

</head>


<body>
    <script type="module" src="./js/UIelements.js"></script>
    <script src="js/sceneStuff.js"></script>
    <script type="module">
        import *  as THREE from "three";
        import { LayeredRender } from "./js/LayeredRender.js"
        import { TransformControls } from 'transformControls';
        import { OrbitControls } from 'orbitControls';
        import { GLTFLoader } from 'gltf';
        import { EWBIK } from "./js/EWBIK/EWBIK.js";
        import { IKNode, TrackingNode } from "./js/EWBIK/util/nodes/IKNodes.js";
        import { IKPin } from "./js/EWBIK/betterbones/IKpin.js";
        import { Rest, Kusudama, Twist } from "./js/EWBIK/betterbones/Constraints/ConstraintStack.js";
        import { getMeshDescendants, initEnvironment } from "enviro";
        //import { Rest } from "./js/EWBIK/betterbones/Constraints/Rest/Rest.js"
        addDebugFuncs(THREE);
        window.Rest = Rest;
        window.OrbitControls = OrbitControls;
        window.TransformControls = TransformControls;
        window.IKNode = IKNode;
        window.TrackingNode = TrackingNode;
        window.IKPin = IKPin;
        window.autoSolve = true;

        window.meshLayer = 0;
        window.boneLayer = 1;

        let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(-0.61, 1.2, -1);
        window.renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setClearColor(0x000000, 0);
        renderer.setSize(window.innerWidth, window.innerHeight);
        window.camera = camera;
        window.renderer = renderer;

        let orbitControls, boneCtrls, pinOrientCtrls, pinTranslateCtrls;
        var scene = null;

        let selectedBone = null;
        let rootBone = null;
        let armature = null;
        let frameCount = 0;
        window.instances = [];

        const loader = new GLTFLoader();

        async function init() {
            scene = new THREE.Scene();
            //scene.add(hemisphereLight);
            window.scene = scene;
            document.body.appendChild(renderer.domElement);
            //scene.add(ambientLight);
            window.addEventListener('resize', onWindowResize, false);
            autoSolve = false;
            interactionSolve = false;
            initControls(THREE, renderer);

            let inst1 = await loadModel({ x: 0, y: 0, z: 0 }, 0, ikify);
            window.nek1 = inst1;
            armature = inst1;
            armature.setDefaultIterations(15);
            armature.setDampening(0.08);
            armature.dirtyRate = true;
            initEnvironment(scene, renderer, //scene,
                [...getMeshDescendants(nek1.armatureObj3d.children[0]),
                ...getMeshDescendants(nek1.rootBone)],
                [0, 1]
            );

            //instances = await Promise.all([inst1, inst2]);
            //armature.solve();
            //render();
        }

        let lastIK = 0;
        function ikify(inst, loadId) {
            window.updateParseStream("Building IK Armature...", loadId);
            let armature = new EWBIK(inst);
            armature.armatureNode.forceOrthonormality = false;
            window.armatures.push(armature);

            window.updateParseStream("Inferring Bone directions and appearance...", loadId);
            initPrettyBones(armature);
            window.updateParseStream("Addings constraints...", loadId);
            initBoneConstraints(armature);
            makePinsList(1, armature.armatureObj3d, armature, true, true);
            window.updateParseStream("UI stuff...", loadId);
            updateGlobalBoneLists();
            render();
            initIK(armature);

            window.updateParseStream(null, loadId);
            return armature;
        }

        function initBoneConstraints(armature) {
            armature.rootJoint = armature.bonetags['_rootJoint'];
            armature.rootJoint.rotateX(-Math.PI / 2);
            armature.hips = armature.bonetags["spine_01"];
            armature.spine_pin = new IKPin(armature.bonetags["spine_01"]);
            armature.left_foot_pin = new IKPin(armature.bonetags["footL_067"]);
            armature.right_foot_pin = new IKPin(armature.bonetags["footR_072"]);
            armature.right_hand_pin = new IKPin(armature.bonetags["forearmR_039"]);
            armature.left_hand_pin = new IKPin(armature.bonetags["handL001_033"]);
            armature.left_hand_pin.setPinWeight(0.038);
            armature.left_hand_pin.setInfluenceOpacity(1-0.947);
            let handL004_036_pin = new IKPin(armature.bonetags["handL004_036"]);
            handL004_036_pin.setPinWeight(0.943);
            armature.delicious_pin = new IKPin(armature.bonetags["spine004_05"]);



            armature.rootJoint.position.y = armature.hips.position.y - 0.01;
            armature.hips.position.y = 0.01;
            armature.makeBoneMesh(armature.hips.parent, armature.hips.parent.boneRadius);

            new Kusudama(armature.bonetags["shoulderL_011"], (t, b) => b == contextBone, "Kusudama for shoulderL_011", armature.stablePool)
                .addLimitConeAtIndex(0, armature.stablePool.any_Vec3(0.9145643117013811, 0.40000099677558526, 0.059760541670215446), 0.4).parentKusudama
                .addLimitConeAtIndex(1, armature.stablePool.any_Vec3(0.9941201456294165, 0.10761166025253095, 0.012036055476837868), 0.55);
            new Twist(armature.bonetags["shoulderL_011"], 0.1, undefined,
                armature.stablePool.any_Vec3(0.9941201456294166, 0.10761166025253095, 0.012036055476837917),
                1.425914460306217, (cnstrt, bone) => bone == contextBone,
                "Twist for shoulderL_011", armature.stablePool);
            new Kusudama(armature.bonetags["shoulderR_037"], (t, b) => b == contextBone, "Kusudama for shoulderR_037", armature.stablePool)
                .addLimitConeAtIndex(0, armature.stablePool.any_Vec3(-0.9145643117013811, 0.40000099677558526, 0.059760541670215446), 0.4).parentKusudama
                .addLimitConeAtIndex(1, armature.stablePool.any_Vec3(-0.9941201456294165, 0.10761166025253095, 0.012036055476837868), 0.55);
            new Twist(armature.bonetags["shoulderR_037"], 0.1, undefined,
                armature.stablePool.any_Vec3(-0.9941201456294166, 0.10761166025253095, 0.012036055476837917),
                1.425914460306217, (cnstrt, bone) => bone == contextBone,
                "Twist for shoulderR_037", armature.stablePool);

            new Kusudama(armature.bonetags["upper_armR_038"], (t, b) => b == contextBone, "Kusudama for upper_armR_038", armature.stablePool)
                .addLimitConeAtIndex(0, armature.stablePool.any_Vec3(-0.918700295443015, 0.22563409263503292, -0.3241589477304035), 1.14738);
            new Twist(armature.bonetags["upper_armR_038"], 1.58915, undefined,
                armature.stablePool.any_Vec3(-0.40658307784607417, 0.8220687777702661, -0.398613957383275),
                0.33363330416059406, (cnstrt, bone) => bone == contextBone,
                "Twist for upper_armR_038", armature.stablePool);

            new Kusudama(armature.bonetags["forearmR_039"], (t, b) => b == contextBone, "Kusudama for forearmR_039", armature.stablePool)
                .addLimitConeAtIndex(0, armature.stablePool.any_Vec3(-0.15650828560707297, 0.987394652013582, 0.02359995151080632), 0.1).parentKusudama
                .addLimitConeAtIndex(1, armature.stablePool.any_Vec3(-0.14917163438267206, -0.7103649491767694, 0.687844068431711), 0.1);
            new Twist(armature.bonetags["forearmR_039"], 1.98429, undefined,
                armature.stablePool.any_Vec3(-0.2484100309166494, 0.9606875386022342, 0.12398350608601774),
                0.08978217516970559, (cnstrt, bone) => bone == contextBone,
                "Twist for forearmR_039", armature.stablePool);

            new Kusudama(armature.bonetags["spine003_04"], (t, b) => b == contextBone, "Kusudama for spine003_04", armature.stablePool)
                .addLimitConeAtIndex(0, armature.stablePool.any_Vec3(0.10812334026603489, 0.5920051616340618, 0.7986483781291638), 0.19481);
            new Twist(armature.bonetags["spine003_04"], 0.95411, undefined,
                armature.stablePool.any_Vec3(0.10812334053790432, 0.592005163122622, 0.7986483801373155),
                0, (cnstrt, bone) => bone == contextBone,
                "Twist for spine003_04", armature.stablePool);
            new Kusudama(armature.bonetags["spine002_03"], (t, b) => b == contextBone, "Kusudama for spine002_03", armature.stablePool)
                .addLimitConeAtIndex(0, armature.stablePool.any_Vec3(0.025223156038351697, 0.957102360424707, -0.2886500720057405), 0.8228);
            new Twist(armature.bonetags["spine002_03"], 0.86944, undefined,
                armature.stablePool.any_Vec3(0.025223156076032826, 0.9571023618545322, -0.2886500724369578),
                0.03081711419171452, (cnstrt, bone) => bone == contextBone,
                "Twist for spine002_03", armature.stablePool);
            new Kusudama(armature.bonetags["spine001_02"], (t, b) => b == contextBone, "Kusudama for spine001_02", armature.stablePool)
                .addLimitConeAtIndex(0, armature.stablePool.any_Vec3(0.10937154349178184, 0.9064908448735991, -0.40781394487507905), 0.42766);
            new Twist(armature.bonetags["spine001_02"], 0.77065, undefined,
                armature.stablePool.any_Vec3(0.10937154321996187, 0.9064908426207066, -0.40781394386154324),
                5.913376748457747, (cnstrt, bone) => bone == contextBone,
                "Twist for spine001_02", armature.stablePool);

            for (let b of armature.bones) {
                if (b.parent instanceof THREE.Bone) {
                    if (b.getConstraint() != null) {
                        b.getConstraint().layers?.set(1);
                        continue;
                    }
                    let restconst = new Rest(b);
                    if (b == armature.bonetags['shoulderR_037']) {
                        restconst.setPainfulness(0.8);
                        restconst.setStockholmRate(0.8);
                    }
                    if (b == armature.bonetags['shoulderL_011']) {
                        restconst.setPainfulness(0.8);
                        restconst.setStockholmRate(0.8);
                    }
                }
            }
        }

        async function loadModel(position, loadId, onloaded) {

            let glb = await loader.loadAsync(
                './gltftests/pyramid_pie-v1.glb',
                (xhr, otherParam) => { window.updateLoadStream(xhr, loadId) },
                (error) => { window.notifyStreamError(error, loadId) }
            );
            let startAt = findBone(glb.scene).parent;
            scene.add(startAt);
            window.updateParseStream("Scene instaniated...", loadId);
            return ikify(startAt, loadId);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            render();
        }

        async function animate() {
            requestAnimationFrame(animate);
            render(true);
        }

        window.render = function (incrFrame = false) {
            if (incrFrame) frameCount++;
            doSolve();

            camera.layers.set(0);
            window.renderer.render(scene, camera);
            window.renderer.clearDepth();
            const currentBackground = scene.background;
            const currentFog = scene.fog;
            scene.background = null;
            scene.fog = null;
            camera.layers.set(1);
            window.renderer.render(scene, camera);

        }


        init();
        animate();
    </script>
</body>

</html>